/ *!
 * Bootstrap v3.3.0 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licenciado sob o MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * /
if ("indefinido" == typeof jQuery) throw new Error ("JavaScript do Bootstrap requer jQuery"); + function (a) {var b = a.fn.jquery.split ("") [0] .split (". "); if (b [0] <2 && b [1] <9 || 1 == b [0] && 9 == b [1] && b [2] <1) lançar novo Erro (" JavaScript do Bootstrap requer o jQuery versão 1.9 .1 ou superior ")} (jQuery), + função (a) {" use strict "; função b () {var a = document.createElement (" bootstrap "), b = {WebkitTransition:" webkitTransitionEnd ", MozTransition: "transitionend", OTransition: "oTransitionEnd otransitionend", transição: "transitionend"} para (var c em b) if (void 0! == a.style [c]) return {end: b [c]}; ! 1} a.fn.emulateTransitionEnd = function (b) {var c =! 1, d = isto; a (isto) .one ("bsTransitionEnd", função () {c =! 0}); var e = função () {c || a (d).trigger (a.support.transition.end)}; retorna setTimeout (e, b), isto}, a (function () {a.support.transition = b (), a.support.transition && (a.event.special .bsTransitionEnd = {bindType: a.support.transition.end, delegateType: a.support.transition.end, identificador: function (b) {return a (b.target) .é (este)? b.handleObj.handler. apply (this, arguments): void 0}})})} (jQuery), + função (a) {"use strict"; função b (b) {retornar this.each (function () {var c = a ( isto), e = c.data ("bs.alert"); e || c.data ("bs.alert", e = novo d (este)), "string" == typeof b && e [b] .call (c)})} var c = '[data-dismiss = "alerta"]', d = função (b) {a (b) .on ("clique", c, this.close)}; d.VERSION = "3.3.0", d.TRANSITION_DURATION = 150, d.prototype.close = function (b) {função c () {g.detach (). Trigger ("closed.bs.alert"). Remove ()} var e = a (isto), f = e.attr ("data-target "); f || (f = e.attr (" href "), f = f & f.replace (/.* (? = # [^ \ s] * $) /," ")); var g = a (f); b && b.preventDefault (), g.length || (g = e.closest (". alerta")), g.trigger (b = a.Event ("close.bs.alert") ), b.isDefaultPrevented () || (g.removeClass ("in"), a.support.transition && g.hasClass ("fade")? g.one ("bsTransitionEnd", c) .emulateTransitionEnd (d.TRANSITION_DURATION): c ())} var e = a.fn.alert a.fn.alert = b, a.fn.alert.Constructor = d, a.fn.alert.noConflict = function () {return a.fn. alert = e, this}, um (documento) .on ("click.bs.alert.data-api", c, d.prototype.close)} (jQuery), + função (a) {"use strict"; função b (b) {retornar this.each (function () {var d = a (isto), e = d.data ("bs.button"), f = "objeto" == typeof b && b; e || d .data ("bs.button", e = novo c (isto, f)), "toggle "== b? e.toggle (): b && e.setState (b)})} var c = função (b, d) {isto. $ elemento = a (b), this.options = a.extend ({ }, c.DEFAULTS, d), this.isLoading =! 1}; c.VERSION = "3.3.0", c.DEFAULTS = {loadingText: "carregando ..."}, c.prototype.setState = function ( b) {var c = "desabilitado", d = este. $ elemento, e = d.is ("entrada")? "val": "html", f = d.data (); b + = "Texto", null == f.resetText && d.data ("resetText", d [e] ()), setTimeout (a.proxy (função () {d [e] (null == f [b]? this.options [b] : f [b]), "loadingText" == b? (this.isLoading =! 0, d.addClass (c) .attr (c, c)): this.isLoading && (this.isLoading =! 1, d. removeClass (c) .removeAttr (c))}, isto), 0)}, c.prototype.toggle = function () {var a =! 0, b = isso. $ element.closest ('[data-toggle = "botões"] '); if (b.length) {var = this. $ element.find ("input"); "radio "== c.prop (" type ") && (c.prop (" marcado ") && this. $ element.hasClass (" ativo ")? a =! 1: b.find (". ativo "). removeClass ("ativo")), a && c.prop ("verificado",! this. $ element.hasClass ("ativo")). trigger ("change")} else else $ element.attr ("aria-pressed", ! this. $ element.hasClass ("active")); a && this. $ element.toggleClass ("ativo")}; var d = a.fn.button; a.fn.button = b, a.fn.button. Constructor = c, a.fn.button.noConflict = function () {return a.fn.button = d, isto}, a (documento) .on ("click.bs.button.data-api", '[dados -toggle ^ = "button"] ', function (c) {var d = a (c.target); d.hasClass ("btn") || (d = d.closest (". btn")), b .call (d, "toggle"), c.preventDefault ()}). on ("focus.bs.button.data-api blur.bs.button.data-api ", '[data-toggle ^ =" botão "]', função (b) {a (b.alvo) .closest (" .btn "). toggleClass (" foco "," foco "= = b.type)})} (jQuery), + função (a) {"use strict", função b (b) {retornar this.each (function () {var d = a (isto), e = d. data ("bs.carousel"), f = a.extend ({}, c.DEFAULTS, d.data (), "objeto" == typeof b && b), g = "string" == tipo de b? b: f .slide; e || d.data ("bs.carossel", e = novo c (isto, f)), "número" == tipo de b? e.to (b): g? e [g] () : f.interval && e.pause (). cycle ()}}} var c = function (b, c) {isto. $ element = a (b), isto. $ indicadores = isto. $ element.find (". carrossel -indicators "), this.options = c, this.paused = this.sliding = this.interval = this. $ active = isto. $ items = null, this.options.keyboard && this. $ element.on (" keydown.bs .carousel ", a.proxy (this.keydown,this)), "hover" == this.options.pause &&! ("ontouchstart" em document.documentElement) && this $ element.on ("mouseenter.bs.carousel", a.proxy (this.pause, this)) .on ("mouseleave.bs.carousel", a.proxy (this.cycle, this)); c.VERSION = "3.3.0", c.TRANSITION_DURATION = 600, c.DEFAULTS = {intervalo: 5e3, pausa : "hover", quebra automática:! 0, teclado:! 0}, c.prototype.keydown = função (a) {switch (a.which) {caso 37: this.prev (); break; case 39: this. next (); break; padrão: return} a.preventDefault ()}, c.prototype.cycle = function (b) {retorno b || (this.paused =! 1), this.interval && clearInterval (this.interval), this.options.interval &&! this.paused && (this.interval = setInterval (a.proxy (this.next, this), this.options.interval)), isso}, c.prototype.getItemIndex = function (a) {return isto. $ items = a.parent (). children (". item"),this. $ items.index (a || this. $ active)}, c.prototype.getItemForDirection = function (a, b) {var = c = "prev" == a? -1: 1, d = this.getItemIndex (b), e = (d + c)% this. $ items.length; devolva isto. $ items.eq (e)}, c.prototype.to = function (a) {var b = isto, c = isto .getItemIndex (this. $ active = this. $ element.find (". item.active")); retorna a> this. $ items.length-1 || 0> a? void 0: this.sliding? this. $ element.one ("slid.bs.carousel", function () {b.to (a)}): c == a? this.pause (). ciclo (): this.slide (a> c? " next ":" prev ", this. $ items.eq (a))}, c.prototype.pause = function (b) {return b || (this.paused =! 0), isso. $ element.find ( ".next, .prev"). length && a.support.transition && (isto. $ element.trigger (a.support.transition.end), this.cycle (! 0)), this.interval = clearInterval (this.interval) , this}, c.prototype.next = function () {return this.sliding? void 0: this.slide ("next")}, c.prototype.prev = function () {retornar this.sliding? void 0: this.slide ("prev")}, c.prototype.slide = function (b, d) {var e = this. $ element.find (". item.active"), f = d || this.getItemForDirection (b, e), g = this.interval, h = "próximo" == b? "left": "right", i = "next" == b? "primeiro": "last", j = isto; if (! f.length) {if (! this.options.wrap) retorno; f = isto. $ elemento .find (". item") [i] ()} if (f.hasClass ("active")) retornar this.sliding =! 1; var k = f [0], l = a.Event ("slide. bs.carousel ", {relatedTarget: k, direção: h}); if (this. $ element.trigger (l),! l.isDefaultPrevented ()) {if (this.sliding =! 0, g && this.pause () , this. $ indicators.length) {this. $ indicators.find (". active"). removeClass ("ativo"); var m = a (this. $ indicators.children () [this.getItemIndex (f)] );milímetros.addClass ("ativo")} var n = a.Event ("slid.bs.carousel", {relatedTarget: k, direção: h}); return a.support.transition && this. $ element.hasClass ("slide")? (f.addClass (b), f [0] .offsetWidth, e.addClass (h), f.addClass (h), e.one ("bsTransitionEnd", function () {f.removeClass ([b, h] .join ("")). addClass ("ativo"), e.removeClass (["ativo", h] .join ("")), j.sliding =! 1, setTimeout (function () {j. $ element.trigger (n)}, 0)}). emulateTransitionEnd (c.TRANSITION_DURATION)) :( e.removeClass ("ativo"), f.addClass ("ativo"), this.sliding =! 1, this. $ element.trigger (n)), g && this.cycle (), isso}}; var d = a.fn.carousel; a.fn.carousel = b, a.fn.carousel.Constructor = c, a.fn.carousel .noConflict = function () {return a.fn.carousel = d, isto}; var e = function (c) {var d, e = a (isto), f = a (e.attr ("alvo de dados")) || (d = e.attr ("href")) && d.replace (/.* (? = # [^ \ s] + $) /, "")); if (f.hasClass ("carrossel") )) {var g = a.extend ({}, f.data (), e.data ()), h = e.attr ("data-slide-to"); h && (g.interval =! 1) , b.call (f, g), h && f.data ("bs.carossel"). para (h), c.preventDefault ()}}; a (documento) .on ("click.bs.carousel.data- api "," [data-slide] ", e). on (" click.bs.carousel.data-api "," [data-slide-to] ", e), a (janela) .on (" load ", function () {a ('[passeio de dados =" carrossel "]'). each (function () {var c = a (this); b.call (c, c.data ())})} )} (jQuery), + função (a) {"use strict", função b (b) {var c, d = b.attr ("data-alvo") || (c = b.attr ("href") ) & & c.replace (/.* (? = # [^ \ s] + $) /, ""); retorno a (d)} função c (b) {retornar this.each (function () {var c = a (isto), e = c.data ("bs.collapse "), f = a.extend ({}, d.DEFAULTS, c.data ()," objeto "== typeof b && b) ;! e && f.toggle &&" show "== b && (f.toggle =! 1), e || c.data ("bs.colapso", e = novo d (isto, f)), "string" == typeof b && e [b] ()})} var d = funç˜ao (b, c ) {this. $ element = a (b), this.options = a.extend ({}, d.DEFAULTS, c), isto. $ trigger = a (this.options.trigger) .filter ('[href = "# '+ b.id +'"], [data-alvo = "# '+ b.id +'"] '), this.transitioning = null, this.options.parent? this. $ parent = this.getParent ( ): this.addAriaAndCollapsedClass (this. $ element, this. $ trigger), this.options.toggle && this.toggle ()}; d.VERSION = "3.3.0", d.TRANSITION_DURATION = 350, d.DEFAULTS = {toggle :! 0, gatilho: '[data-toggle = "colapso"]'}, d.prototype.dimension = function () {var a = isso. $ Element.hasClass ("width "); retorna um" largura ":" altura "}, d.prototype.show = function () {if (! this.transitioning &&! this. $ element.hasClass (" in ")) {var b, e = this. $ parent && this. $ parent.find ("> .panel"). children (". em, .collapsing"); if (! (e && e.length && (b = e.data ("bs.collapse"), b && b.transitioning))) {var f = a.Event ("show.bs.collapse"); if (isso. $ element.trigger (f),! f.isDefaultPrevented ()) {e && e.length && (c.call (e, "hide"), b || e.data ("bs.colapso", nulo)); var g = this.dimension (); isso. $ element.removeClass ("colapso"). addClass ("colapso ") [g] (0) .attr (" aria-expandido ",! 0), isto. $ trigger.removeClass (" collapsed "). attr (" aria-expandido ",! 0), this.transitioning = 1 ; var h = function () {este. $ elemento.removeClass ("colapso"). addClass ("colapso em") [g] (""), this.transitioning = 0, isso. $ element.trigger ("shown.bs.collapse")}; if (! a. support.transition) retornar h.call (this); var eu = a.camelCase (["scroll", g] .join ("-")); isso. $ element.one ("bsTransitionEnd", a.proxy ( h, this)). emulateTransitionEnd (d.TRANSITION_DURATION) [g] (isto. $ element [0] [i])}}}}, d.prototype.hide = function () {if (! this.transitioning && this. $ element.hasClass ("in")) {var b = a.Event ("hide.bs.collapse"); if (isso. $ element.trigger (b),! b.isDefaultPrevented ()) {var c = this .dimension (); this. $ element [c] (isso. $ element [c] ()) [0] .offsetHeight, isso. $ element.addClass ("colapso"). removeClass ("colapso em"). ("aria-expandido",! 1), isto. $ trigger.addClass ("collapsed"). attr ("aria-expandido ",! 1), this.transitioning = 1; var e = função () {this.transitioning = 0, isto. $ element.removeClass (" colapso "). addClass (" colapso "). trigger (" hidden.bs.collapse ")}; return a.support.transition? anule isto. $ element [c] (0) .one (" bsTransitionEnd ", a.proxy (e, isto)). emulateTransitionEnd (d.TRANSITION_DURATION) : e.call (this)}}}, d.prototype.toggle = function () {this [isso. $ element.hasClass ("in")? "hide": "show"] ()}, d.prototype .getParent = function () {return a (this.options.parent) .find ('[data-toggle = "colapso"] [data-parent = "' + this.options.parent + '"]'). a.proxy (função (c, d) {var e = a (d); this.addAriaAndCollapsedClass (b (e), e)}, this)) end ()}, d.prototype.addAriaAndCollapsedClass = function (a b) {var c = a.hasClass ("in"); a.attr ("aria-expandido",c), b.toggleClass ("colapsado",! c) .attr ("aria-expandido", c)}; var e = a.fn.collapse; a.fn.collapse = c, a.fn.collapse. Construtor = d, a.fn.collapse.noConflict = function () {retornar a.fn.collapse = e, this}, a (documento) .on ("click.bs.collapse.data-api", '[dados -toggle = "colapso"] ', função (d) {var e = a (isto); e.attr ("meta de dados") || d.preventDefault (); var f = b (e), g = f.data ("bs.collapse"), h = g? "alternar": a.extend ({}, e.data (), {trigger: this}); c.call (f, h)})} (jQuery), + função (a) {"use strict", função b (b) {b && 3 === b.which || (a (e) .remove (), a (f) .each (function () {var d = a (isto), e = c (d), f = {relatedTarget: this}; e.hasClass ("open") && (e.trigger (b = a.Event ("hide.bs.dropdown ", f)), b.isDefaultPrevented () || (d.attr (" aria-expandido "," false "), e.removeClass ("open "). trigger (" hidden.bs.dropdown ", f)))}))} function c (b) {var = b.attr (" data-target "); c || (c = b. attr ("href"), c = c && / # [A-Za-z] /. teste (c) && c.replace (/.* (? = # [^ \ s] * $) /, "")) ; var d = c && a (c); retorno d && d.length? d: b.parent ()} função d (b) {retornar this.each (function () {var c = a (este), d = c.data ("bs.dropdown"); d || c.data ("bs.dropdown", d = new g (this)), "string" == typeof b && d [b] .call (c)})} var e = ". dropdown-backdrop", f = '[data-toggle = "lista suspensa"]', g = função (b) {a (b) .on ("click.bs.dropdown", this.toggle)}; g.VERSION = "3.3.0", g.prototype.toggle = function (d) {var e = a (isto); if (! e.is (". disabled,: disabled")) {var f = c (e), g = f.hasClass ("open"); if (b (), g) {"ontouchstart" em document.documentElement &&! f.closest (". navbar-nav"). comprimento && a ('<div class = "contexto da lista suspensa" />'). insertAfter (a (this)). on ("clique", b); var h = {relatedTarget: this}; if (f.trigger (d = a.Event ("show.bs.dropdown", h)), d.isDefaultPrevented ()) return e e.trigger ("focus"). attr ( "aria-expandido", "true"), f.toggleClass ("open"). gatilho ("shown.bs.dropdown", h)} return! 1}}, g.prototype.keydown = function (b) { if (/ (38 | 40 | 27 | 32) /. teste (b.which)) {var d = a (isto); if (b.preventDefault (), b.stopPropagation () ,! d.is (" .disabled,: disabled ")) {var e = c (d), g = e.hasClass (" open "); if (! g && 27! = b.which || g && 27 == b.which) return 27 == b.which && e.find (f) .trigger ("focus"), d.trigger ("clique"); var h = "li: não (.divider): visível a", i = e.find ('[role = "menu"] '+ h +', [papel = "listbox"] '+ h); if (i.length) {var j = i.index (b.target); 38 == b.que && j> 0 && j -, 40 == b.que && j <i.length-1 && j ++, ~ j || (j = 0), ou seja, (j) .trigger ("focus")}}}}; var h = a. fn.dropdown; a.fn.dropdown = d, a.fn.dropdown.Construtor = g, a.fn.dropdown.noConflict = função () {return a.fn.dropdown = h, isto}, a (documento) .on ("click.bs.dropdown.data-api", b) .on ("click.bs.dropdown.data-api", ". formulário suspenso", function (a) {a.stopPropagation ()}) .on ("click.bs.dropdown.data-api", f, g.prototype.toggle) .on ("keydown.bs.dropdown.data-api", f, g.prototype.keydown) .on (" keydown.bs.dropdown.data-api ", '[role =" menu "]', g.prototype.keydown). (" keydown.bs.dropdown.data-api ", '[role =" listbox "] g.prototype.keydown)} (jQuery), + função (a) {"use strict"; função b (b, d) {retornar this.each (function () {var e = a (isto), f = e.data ("bs.modal"), g = a.extend ({}, c.DEFAULTS, e.data (), "objeto" == typeof b && b); f || e.data ("bs.modal", f = new c (this, g)), "string" == typeof b? f [b] (d): g.show && f.show (d)})} var c = funo (b, c) {this.options = c, this. $ body = a (document.body), this. $ element = a (b), this. $ backdrop = this.isShown = null, this.scrollbarWidth = 0, this.options.remote && this. $ elemento .find (". modal-content"). load (this.options.remote, a.proxy (function () {isto. $ element.trigger ("loaded.bs.modal")}, isto))}; c .VERSION = "3.3.0", c.TRANSITION_DURATION = 300, c.BACKDROP_TRANSITION_DURATION = 150, c.DEFAULTS = {pano de fundo:! 0, teclado:! 0, show:! 0}, c.prototype.toggle = function ( a) {return this.isShown? this.hide (): isso.show (a)}, c.prototype.show = função (b) {var d = isso, e = a.Event ("show.bs.modal", {relatedTarget: b}); isso. $ element.trigger ( e), this.isShown || e.isDefaultPrevented () || (this.isShown =! 0, this.checkScrollbar (), este. $ body.addClass ("modal-open"), this.setScrollbar (), este .escape (), isto $ element.on ("click.dismiss.bs.modal", '[data-dismiss = "modal"]', a.proxy (this.hide, this)), this.backdrop ( function () {var e = a.support.transition && d. $ element.hasClass ("fade"); d. $ element.parent (). length || d. $ element.appendTo (d. $ body), d. $ element.show (). scrollTop (0), e && d. $ element [0] .offsetWidth, d. $ element.addClass ("em"). attr ("aria-hidden",! 1), d.enforceFocus ( ); var f = a.Event ("shown.bs.modal", {relatedTarget: b}); e? d. $ element.find (". modal-dialog"). um ("bsTransitionEnd",function () {d. $ element.trigger ("focus"). trigger (f)}). emulateTransitionEnd (c.TRANSITION_DURATION): d. $ element.trigger ("focus"). gatilho (f)}))} , c.prototype.hide = function (b) {b && b.preventDefault (), b = a.Event ("hide.bs.modal"), isto. $ element.trigger (b), this.isShown &&! b.isDefaultPrevented () && (this.isShown =! 1, this.escape (), a (documento) .off ("focusin.bs.modal"), isto. $ element.removeClass ("in"). attr ("aria- oculto ",! 0) .off (" click.dismiss.bs.modal "), a.support.transition && this. $ element.hasClass (" fade ")? this. $ element.one (" bsTransitionEnd ", a.proxy (this.hideModal, this)). emulateTransitionEnd (c.TRANSITION_DURATION): this.hideModal ())}, c.prototype.enforceFocus = function () {a (documento) .off ("focusin.bs.modal"). em ("focusin.bs.modal", a.proxy (function (a) {this. $ element [0] === a.target || isto. $ element.has (a.target) .length || isto. $ element.trigger ("focus")}, this)), c.prototype.escape = function () {this.isShown && this.options.keyboard? this. $ element.on ("keydown.dismiss.bs.modal", a.proxy (função (a) {27 == a.which && this.hide ()}, this)): this.isShown || this. $ element.off ("keydown.dismiss.bs.modal")}, c.prototype.hideModal = function () {var a = this; this. $ element.hide (), this.backdrop (function () {a. $ body.removeClass ("modal-open"), a.resetScrollbar (), um. $ element.trigger ("oculto .bs.modal ")})}, c.prototype.removeBackdrop = function () {this. $ backdrop && this. $ backdrop.remove (), isto. $ backdrop = null}, c.prototype.backdrop = function (b) {var d = isso, e = isso. $ element.hasClass ("fade")? "fade": ""; if (this.isShown && this.options.pano de fundo) {var f = a.support.transition &&e; if (this. $ backdrop = a ('<div class = "modal-pano de fundo' + e + '" />'). prependTo (this. $ element) .on ( "click.dismiss.bs.modal", a.proxy (função (a) {a.target === a.currentTarget && ("static" == this.options.backdrop? this. $ element [0] .focus. call (this. $ element [0]): this.hide.call (this))}, this)), f && this. $ backdrop [0] .offsetWidth, isso. $ backdrop.addClass ("in"),! b ) return; f. this. $ backdrop.one ("bsTransitionEnd", b) .emulateTransitionEnd (c.BACKDROP_TRANSITION_DURATION): b ()} mais if (! this.isShown && this. $ backdrop) {this. $ backdrop.removeClass (" em "); var g = função () {d.removeBackdrop (), b && b ()}; a.support.transition && this. $ element.hasClass (" fade ")? this. $ backdrop.one (" bsTransitionEnd ", g ).emulateTransitionEnd (c.BACKDROP_TRANSITION_DURATION): g ()} mais b && b ()}, c.prototype.checkScrollbar = function () {this.scrollbarWidth = this.measureScrollbar ()}, c.prototype.setScrollbar = function () {var = parseInt (isso. $ body.css ("padding-right") || 0,10); this.scrollbarWidth && this. $ body.css ("preenchimento-direito", a + this.scrollbarWidth)}, c.prototype. resetScrollbar = function () {isto. $ body.css ("padding-right", "")}, c.prototype.measureScrollbar = function () {if (document.body.clientWidth> = window.innerWidth) retorna 0; var a = document.createElement ("div"); a.className = "modal-scrollbar-measure", this. $ body.append (a); var b = a.offsetWidth-a.clientWidth; retorne isso. $ body [0] .removeChild (a), b}; var d = a.fn.modal; a.fn.modal = b, a.fn.modal.Constructor = c, a.fn.modal.noConflict = function () {return a.fn.modal = d, this},a (documento) .on ("click.bs.modal.data-api", '[data-toggle = "modal"]', função (c) {var d = a (isto), e = d.attr ( "href"), f = a (d.attr ("destino de dados") || e && e.replace (/.* (? = # [^ \ s] + $) /, "")), g = f .data ("bs.modal")? "toggle": a.extend ({remoto:! / # /. teste (e) && e}, f.data (), d.data ()); d.is ( "a") && c.preventDefault (), f.one ("show.bs.modal", função (a) {a.isDefaultPrevented () || f.one ("hidden.bs.modal", function () { d.is (": visible") && d.trigger ("focus")})}), b.call (f, g, isto)})} (jQuery), + função (a) {"use strict"; função b (b) {retornar this.each (function () {var d = a (isto), e = d.data ("bs.tooltip"), f = "objeto" == typeof b && b, g = f && f. selector; (e || "destruir"! = b) && (g? (e || d.data ("bs.tooltip ", e = {}), e [g] || (e [g] = novo c (isto, f))): e || d.data (" bs.tooltip ", e = novo c (este , f)), "string" == typeof b && e [b] ())})} var c = função (a, b) {this.type = this.options = this.enabled = this.timeout = this.hoverState = this. $ element = null, this.init ("tooltip", a, b)}; c.VERSION = "3.3.0", c.TRANSITION_DURATION = 150, c.DEFAULTS = {animação:! 0, posicionamento: "top", seletor:! 1, modelo: '<div class = "tooltip" role = "tooltip"> <div-class = "tooltip-arrow"> </ div> <div-classe = "tooltip-inner"> < / div> </ div> ', trigger: "foco em foco", título: "", atraso: 0, html:! 1, contêiner:! 1, viewport: {seletor: "body", preenchimento: 0}}, c.prototype.init = function (b, c, d) {this.enabled =! 0, this.type = b, isto. $ element = a (c), this.options = this.getOptions (d), este .$ viewport = this.options.viewport && a (this.options.viewport.selector || this.options.viewport); para (var e = this.options.trigger.split (""), f = e.length; f- -;) {var g = e [f]; se ("clique" == g) isso $ element.on ("clique" + este. tipo, this.options.selector, a.proxy (this.toggle , else) if ("manual"! = g) {var h = "pairar" == g? "mouseenter": "focusin", i = "pairar" == g? "mouseleave": "focusout" ; this. $ element.on (h + "." + this.type, this.options.selector, a.proxy (this.enter, this)), isto. $ element.on (i + "." + this.type , this.options.selector, a.proxy (this.leave, this))}} this.options.selector? this._options = a.extend ({}, this.options, {trigger: "manual", seletor: ""}): this.fixTitle ()}, c.prototype.getDefaults = function () {retornar c.DEFAULTS}, c.prototype.getOptions = function (b) {return b = a.extend ({}, this.getDefaults (), isto. $ element.data (), b), b.delay && "número" == typeof b.delay && (b. delay = {show: b.delay, esconder: b.delay}), b}, c.prototype.getDelegateOptions = function () {var b = {}, c = this.getDefaults (); retorne this._options && a.each (this._options, function (a, d) {c [a]! = d && (b [a] = d)}), b}, c.prototype.enter = função (b) {var c = b exemplo desta construtor? b: a (b.currentTarget) .data ("bs." + this.type); retorno c && c. $ tip && c. $ tip.is (": visible")? void (c.hoverState = "in" ): (c || (c = new this.constructor (b.currentTarget, this.getDelegateOptions ()), a (b.currentTarget) .data ("bs." + this.type, c)), clearTimeout (c .timeout), c.hoverState = "in", c.options.delay && c.options.delay.show? void (c.timeout = setTimeout (function () {"in" == c.hoverState && c.show ()}, c.options.delay.show)): c.show ())}, c.prototype.leave = function (b) {var = b instanceof this.constructor? b: a (b .currentTarget) .data ("bs." + this.type); return c || (c = novo this.constructor (b.currentTarget, this.getDelegateOptions ()), a (b.currentTarget) .data ("bs . "+ this.type, c)), clearTimeout (c.timeout), c.hoverState =" out ", c.options.delay && c.options.delay.hide? void (c.timeout = setTimeout (function () { "out" == c.hoverState && c.hide ()}, c.options.delay.hide)): c.hide ()}, c.prototype.show = função () {var b = a.Event ("mostrar .bs. "+ this.type); if (this.hasContent () && this.enabled) {this. $ element.trigger (b); var d = a.contains (isto. $ element [0] .ownerDocument.documentElement , $ element [0]); if (b.isDefaultPrevented () ||! d) return; var e = isto, f = this.tip (), g = this.getUID (this.type);setContent (), f.attr ("id", g), isto $ element.attr ("aria-describedby", g), this.options.animation && f.addClass ("fade"); var h = "função" == typeof this.options.placement? this.options.placement.call (isto, f [0], isto. $ element [0]): this.options.placement, i = / \ s? auto? \ s? /i,j=i.test(h);j&&(h=h.replace(i,"")||"top"),f.detach().css({top:0,left:0,display : "bloco"}). addClass (h) .data ("bs." + this.type, this), this.options.container? f.appendTo (this.options.container): f.insertAfter (this. $ elemento) var k = this.getPosition (), l = f [0] .offsetWidth, m = f [0] .offsetHeight; se (j) {var n = h, o = este.opções.container? this.options.container): $ element.parent (), p = this.getPosition (o); h = "bottom" == h && k.bottom + m> p.bottom? "top": "top" = = h && k.top-m <p.top? "bottom": "right" == h && k.right + l> p.width? "left": "left" == h && k.left-l <p.left? "right": h, f.removeClass ( n) .addClass (h)} var q = this.getCalculatedOffset (h, k, l, m); this.applyPlacement (q, h); var r = função () {var a = e.hoverState; e. $ element.trigger ("shown.bs." + e.type), e.hoverState = nulo, "out" == a && e.leave (e)}; a.support.transition && this. $ tip.hasClass ("fade") ? f.one ("bsTransitionEnd", r) .emulateTransitionEnd (c.TRANSITION_DURATION): r ()}}, c.prototype.applyPlacement = function (b, c) {var d = este.tip (), e = d [0] .offsetWidth, f = d [0] .offsetHeight, g = parseInt (d.css ("margem superior"), 10), h = parseInt (d.css ("margem esquerda"), 10) ; isNaN (g) && (g = 0), isNaN (h) && (h = 0), b.top = b.top + g, b.left = b.left + h, a.offset.setOffset (d [0], a.extend ({usando:function (a) {d.css ({topo: Math.round (a.top), esquerda: Math.round (a.left)})}}, b), 0), d.addClass ("in") ; var i = d [0] .offsetWidth, j = d [0] .offsetHeight; "topo" == c && j! = f && (b.top = b.top + fj); var k = este.getViewportAdjustedDelta (c, b, i, j); k.left? b.left + = k.left: b.top + = k.top; var l = / topo | fundo / .teste (c), m = l? 2 * k.left -e + i: 2 * k.top-f + j, n = l "offsetWidth": "offsetHeight"; d.offset (b), this.replaceArrow (m, d [0] [n], l) }, c.prototype.replaceArrow = function (a, b, c) {this.arrow (). css (c? "esquerda": "top", 50 * (1-a / b) + "%"). css (c? "top": "esquerda", "")}, c.prototype.setContent = function () {var a = este.tip (), b = this.getTitle (); a.find (". tooltip-inner ") [this.options.html?" html ":" texto "] (b), a.removeClass (" desvanece-se no canto superior esquerdo inferior direito ")}, c.prototype.hide = function (b) {função d () {"em"! = e.hoverState && f.detach (), e $ element.removeAttr ("aria-describedby"). trigger ("hidden.bs." + e. type), b && b ()} var e = this, f = this.tip (), g = a.Event ("hide.bs." + this.type); retorne isto. $ element.trigger (g), g .isDefaultPrevented ()? void 0: (f.removeClass ("in"), a.support.transition && this. $ tip.hasClass ("fade")? f.one ("bsTransitionEnd", d) .emulateTransitionEnd (c.TRANSITION_DURATION ): d (), this.hoverState = null, this)}, c.prototype.fixTitle = function () {var a = isto. $ element; (a.attr ("title") || "string"! typeof a.attr ("data-original-title")) && a.attr ("data-original-título", a.attr ("título") || ""). attr ("título", "")} , c.prototype.hasContent = function () {return this.getTitle ()}, c.prototype.getPosition = function (b) {b = b || este. $ elemento; var c = b [0], d = "CORPO" == c.tagName, e = c.getBoundingClientRect (); null == e .width && (e = a.extend ({}, e, {largura: e.right-e.left, altura: e.bottom-e.top})); var f = d? {topo: 0, esquerda: 0}: b.offset (), g = {rolagem: d? Document.documentElement.scrollTop || document.body.scrollTop: b.scrollTop ()}, h = d? {Largura: a (janela) .width ( ), height: a (janela) .height ()}: null; retorna a.extend ({}, e, g, h, f)}, c.prototype.getCalculatedOffset = function (a, b, c, d) {return "bottom" == a? {superior: b.top + b.height, left: b.left + b.width / 2-c / 2}: "topo" == a? {top: b.top -d, esquerda: b.left + b.width / 2-c / 2}: "esquerda" == a? {superior: b.top + b.height / 2-d / 2, esquerda: b.left- c}: {top: b.top + b.alta / 2-d / 2, esquerda: b.left + b.width}}, c.prototype.getViewportAdjustedDelta = função (a, b, c, d) {var e = {top: 0, left: 0}, se (! this. $ viewport) retornar e; var f = this.options.viewport && this.options.viewport.padding || 0, g = this.getPosition (this. $ viewport); if (/right|left/.test (a)) {var h = b.top-fg.scroll, i = b. top + fg.scroll + d; h <g.top?e.top=g.top-h:i> g.top + g.height&& (e.top = g.top + g.height-i)} mais {var j = b.left-f, k = b.left + f + c; j <g.left? e.left = g.left-j: k> g.width && (e.left = g.left + g.width-k)} return e}, c.prototype.getTitle = function () {var a, b = isso. $ element, c = this.options; retorno a = b.attr ("data-original-title ") || (" função "== tipo de c.title? c.title.call (b [0]): c.title)}, c.prototype.getUID = função (a) {do a + = ~~ ( 1e6 * Math.random ()); while (document.getElementById (a)); retorne a}, c.prototype.tip = function () {retorne isto. $ Tip = this. $ Tip || a (this.options .template)}, c.prototype.arrow = function () {retorne isto. $ arrow = this. $ arrow || this.tip (). find (". tooltip-arrow")}, c.prototype.enable = function () {this.enabled =! 0}, c.prototype.disable = function () {this.enabled =! 1}, c.prototype.toggleEnabled = function () {this.enabled =! this.enabled}, c.prototype.toggle = função (b) {var c = this; b && (c = a (b.currentTarget) .data ("bs." + this.type), c || (c = novo this.constructor (b.currentTarget, this.getDelegateOptions ()), a (b .currentTarget) .data ("bs." + this.type, c))), c.tip (). hasClass ("em")? ​​c.leave (c): c.enter (c)}, c. prototype.destroy = function () {var a = isto; clearTimeout (this.timeout), this.hide (function () {a. $ element.off ("." + a.type) .removeData ("bs." + a.type)})}; var d = a.fn.tooltip; a.fn.tooltip = b, a.fn.tooltip.Constructor = c, a.fn.tooltip.noConflict = function () {retornar a .fn.tooltip = d, isto}} (jQuery), + função (a) {"use strict"; função b (b) {retornar this.each (function () {var d = a (isto), e = d.data ("bs.popover"), f = "objeto" == typeof b && b, g = f && f.selector; (e || "destruir"! = b) && (g? (e || d.data ("bs.popover", e = {}), e [g] || ( e [g] = novo c (isto, f))): e || d.data ("bs.popover", e = novo c (isto, f)), "string" == typeof b && e [b] ( ))}}} var c = função (a, b) {this.init ("popover", a, b)}; se (! a.fn.tooltip) lançar novo erro ("Popover requires tooltip.js") c.VERSION = "3.3.0", c.DEFAULTS = a.extend ({}, a.fn.tooltip.Constructor.DEFAULTS, {placement: "right", trigger: "clique", conteúdo: "", template: '<div class = "popover" role = "tooltip"> <div class = "arrow"> </ div> <h3 class = "popover-título"> </ h3> <div class = "popover-content "> </ div> </ div> '}), c.prototype = a.extend ({}, a.fn.tooltip.Constructor.prototype), c.prototype.construtor = c, c.prototype.getDefaults = function () {retornar c.DEFAULTS}, c.prototype.setContent = function () {var a = this.tip (), b = this.getTitle (), c = este .getContent (); a.find (". popover-title") [this.options.html? "html": "texto"] (b), a.find (". popover-content"). children () .detach (). end () [this.options.html? "string" == typeof c? "html": "append": "texto"] (c), a.removeClass ("desvanece-se no canto superior esquerdo inferior direito "), a.find (". popover-title "). html () || a.find (". popover-title "). hide ()}, c.prototype.hasContent = function () {retorne isso. getTitle () || this.getContent ()}, c.prototype.getContent = function () {var a = isso. $ element, b = this.options; retorno a.attr ("data-content") || ( "function" == typeof b.content? b.content.call (a [0]): b.content)}, c.prototype.arrow = function () {retorne isto.$ arrow = this. $ arrow || this.tip (). find (". arrow")}, c.prototype.tip = function () {retorne isto. $ tip || (isto. $ tip = a .options.template)), isto. $ tip}; var d = a.fn.popover; a.fn.popover = b, a.fn.popover.Constructor = c, a.fn.popover.noConflict = function ( ) {return a.fn.popover = d, isto}} (jQuery), + função (a) {"use strict"; função b (c, d) {var e = a.proxy (this.process, this) ; this. $ body = a ("body"), this. $ scrollElement = a (a (c) .is ("body")? janela: c), this.options = a.extend ({}, b. DEFAULTS, d), this.selector = (this.options.target || "") + ".nav li> a", this.offsets = [], this.targets = [], this.activeTarget = null, este .scrollHeight = 0, this. $ scrollElement.on ("scroll.bs.scrollspy", e), this.refresh (), this.process ()} função c (c) {retornar this.each (function () { var d = a (isto), e = d.data ("bs.scrollspy"), f = "objeto"== typeof c && c; e || d.data ("bs.scrollspy", e = novo b (isto, f)), "string" == typeof c && e [c] ()})} b.VERSION = "3.3 .0 ", b.DEFAULTS = {deslocamento: 10}, b.prototype.getScrollHeight = function () {retorne isso. $ ScrollElement [0] .scrollHeight || Math.max (this. $ Body [0] .scrollHeight, document.documentElement.scrollHeight)}, b.prototype.refresh = function () {var b = "deslocamento", c = 0; a.isWindow (isto. $ scrollElement [0]) || (b = "posição", c = this. $ scrollElement.scrollTop ()), this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight (); var d = isso; isso. $ body.find (isso. selector) .map (function () {var d = a (isto), e = d.data ("alvo") || d.attr ("href"), f = / ^ #. /. teste (e) && a (e); return f && f.length && f.is (": visible") && [[f [b] (). top + c, e]] || null}). sort (função (a, b) {retorno a [0] -b [0]}).each (function () {d.offsets.push (this [0]), d.targets.push (this [1])})}, b.prototype.process = function () {var a, b = isso. $ scrollElement.scrollTop () + this.options.offset, c = this.getScrollHeight (), d = this.options.offset + c-this $ scrollElement.height (), e = this.offsets, f = isto. alvos, g = this.activeTarget; if (this.scrollHeight! = c && this.refresh (), b> = d) retorno g! = (a = f [comprimento_length] 1) && this.activate (a); (g && b <e [0]) return this.activeTarget = null, this.clear (); para (a = e.length; a -;) g! = f [a] && b> = e [a] && ( ! e [a + 1] || b <= e [a + 1]) && this.activate (f [a])}, b.prototype.activate = function (b) {this.activeTarget = b, this.clear (); var c = este.selector + '[data-alvo = "' + b + '"],' + este.selector + '[href = "' + b + '"]', d = a (c) .parents ( "li"). addClass ("ativo"); d.parent (".dropdown-menu "). length && (d = d.closest (" li.dropdown "). addClass (" ativo ")), d.trigger (" activate.bs.scrollspy ")}, b.prototype.clear = function () {a (this.selector) .parentsUntil (this.options.target, ". active"). removeClass ("ativo")}; var d = a.fn.scrollspy; a.fn.scrollspy = c, a .fn.scrollspy.Constructor = b, a.fn.scrollspy.noConflict = function () {retornar a.fn.scrollspy = d, isto}, a (janela) .on ("load.bs.scrollspy.data-api ", function () {a ('[data-spy =" rolar "]'). each (function () {var b = a (isso); c.call (b, b.data ())})} )} (jQuery), + função (a) {"use strict", função b (b) {retornar this.each (function () {var d = a (isto), e = d.data ("bs.tab "); e || d.data (" bs.tab ", e = novo c (este))," string "== typeof b && e [b] ()})} var c = função (b) {this. elemento = a (b)}; c.VERSION = "3.3.0 ", c.TRANSITION_DURATION = 150, c.prototype.show = function () {var b = este.elemento, c = b.closest (" ul: não (.dropdown-menu) "), d = b.data ("target"); if (d || (d = b.attr ("href"), d = d && d.replace (/.* (? = # [^ \ s] * $) /, "")) ,! b.parent ("li"). hasClass ("ativo")) {var e = c.find (". ativo: last a"), f = a.Event ("hide.bs.tab", { relatedTarget: b [0]}), g = a.Event ("show.bs.tab", {relatedTarget: e [0]}), se (e.trigger (f), b.trigger (g),! g.isDefaultPrevented () &&! f.isDefaultPrevented ()) {var h = a (d); this.activate (b.closest ("li"), c), this.activate (h, h.parent (), function () {e.trigger ({tipo: "hidden.bs.tab", relatedTarget: b [0]}), b.trigger ({tipo: "shown.bs.tab", relatedTarget: e [0]} )})}}}, c.prototype.activate = function (b, d, e) {função f () {g.removeClass ("ativo"). find ("> .dropdown-menu> .active "). removeClass (" ativo "). end (). find ('[dados-toggle =" tab "]'). attr (" aria-expandido ",! 1), b .addClass ("ativo"). find ('[data-toggle = "tab"]'). attr ("aria-expandido",! 0), h? (b [0] .offsetWidth, b.addClass (" em ")): b.removeClass (" fade "), b.parent (". menu dropdown ") && b.closest (" li.dropdown "). addClass (" ativo "). end (). find (' [data-toggle = "tab"] '). attr ("aria-expandido",! 0), e && e ()} var g = d.find ("> .active"), h = e && a.support.transition && ( g.length && g.hasClass ("fade") || !! d.find ("> .fade"). length); g.length && h? g.one ("bsTransitionEnd", f) .emulateTransitionEnd (c.TRANSITION_DURATION): f (), g.removeClass ("em ")}; var d = a.fn.tab; a.fn.tab = b, a.fn.tab.Constructor = c, a.fn.tab.noConflict = function () {return a.fn.tab = d, isso}; var e = function (c) {c.preventDefault (), b.call (a (isso), "show")}; a (documento) .on ("click.bs.tab.data -api ", '[data-toggle =" tab "]', e) .on (" click.bs.tab.data-api ", '[data-toggle =" comprimido "]', e)
} (jQuery), + função (a) {"use strict", função b (b) {retornar this.each (function () {var d = a (isso), e = d.data ("bs.affix" ), f = "objeto" == typeof b && b; e || d.data ("bs.affix", e = novo c (isto, f)), "string" == typeof b && e [b] ()}) } var c = função (b, d) {this.options = a.extend ({}, c.DEFAULTS, d), isto. $ target = a (this.options.target) .on ("scroll.bs. affix.data-api ", a.proxy (this.checkPosition, this)). on (" click.bs.affix.data-api ", a.proxy (this.checkPositionWithEventLoop, this)), isto. $ element = a (b), this.affixed = this.unpin = this.pinnedOffset = null, this.checkPosition ()}; c.VERSION = "3.3.0", c.RESET = "afix-affix-top affix-bottom", c.DEFAULTS = {deslocamento: 0, target: window}, c.prototype.getState = function (a, b, c, d) {var e = this. $ target.scrollTop (), f = este. $ elemento. offset (), g = isso. $ target.height (); if (null!= c && "top" == this.affixed) return c> e? "top":! 1; if ("bottom" == this.affixed) retorna null! = c? e + this.unpin <= f.top 1: "bottom": ad> = e + g?! 1: "bottom"; var h = null == this.affixed, i = h? E: f.top, j = h? G: b; return null! = c && c> = i? "top": null! = d && i + j> = anúncio? "bottom":! 1}, c.prototype.getPinnedOffset = function () {if (this.pinnedOffset) retorna isso. pinnedOffset; this. $ element.removeClass (c.RESET) .addClass ("affix"); var a = isso. $ target.scrollTop (), b = isso. $ element.offset (); return this.pinnedOffset = b .top-a}, c.prototype.checkPositionWithEventLoop = function () {setTimeout (a.proxy (this.checkPosition, this), 1)}, c.prototype.checkPosition = function () {se (isto. $ elemento. é (": visible")) {var b = isso. $ element.height (), d = this.options.offset, e = d.top, f = d.bottom, g = a ("corpo").height (); "objeto"! = typeof d && (f = e = d), "função" == typeof e && (e = d.top (this. $ element)), "função" == typeof f && (f = d.bottom (this. $ element)); var h = this.getState (g, b, e, f); if (this.affixed! = h) {null! = this.unpin && este. $ element.css (" top "," "); var i =" afixo "+ (h?" - "+ h:" "), j = a.Evento (i +". bs.affix "); if (this. $ element.trigger (j), j.isDefaultPrevented ()) return; this.affixed = h, this.unpin = "bottom" == h? this.getPinnedOffset (): null, isto. $ element.removeClass (c.RESET) .addClass (i) .trigger (i.replace ("afixo", "afixado") + ". bs.affix")} "bottom" == h && this. $ element.offset ({top: gbf})}}; var d = a.fn.affix; a.fn.affix = b, a.fn.affix.Constructor = c, a.fn.affix.noConflict = function () {retorno a.fn.affix = d, este}, um (janela).on ("load", função () {a ('[data-spy = "affix"]'). each (function () {var = a (isto), d = c.data (); d.offset = d.offset || {}, null! = d.offsetBottom && (d.offset.bottom = d.offsetBottom), nulo! = d.offsetTop && (d.offset.top = d.offsetTop), b.call (c d)})})} (jQuery);
