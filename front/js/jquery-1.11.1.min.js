/ *! jQuery v1.11.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license * /
! function (a, b) {"objeto" == tipo de módulo && "objeto" == tipo de módulo module.exports? module.exports = a.document? b (a,! 0): function (a) {if (! a .document) throw new Erro ("jQuery requer uma janela com um documento"); return b (a)}: b (a)} (janela "indefinida"! = typeof window?: this, function (a, b) { var c = [], d = c.slice, e = c.concat, f = c.push, g = c.indexOf, h = {}, i = h.toString, j = h.hasOwnProperty, k = { }, l = "1.11.1", m = função (a, b) {retornar novo m.fn.init (a, b)}, n = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g, o = / ^ - ms - /, p = / - ([\ da-z]) / gi, q = função (a, b) {retorno b.toUpperCase ()} ; m.fn = m.prototype = {jquery: l, construtor: m, seletor: "", length: 0, toArray: function () {retorno d.call (this)}, get: function (a) {return null! = a? 0> a? isto [a + este.length]: este [a]: d.call (this)}, pushStack: function (a) {var b = m.merge (this.constructor () , a); return b.prevObject = isto, b.context = this.context, b}, cada: function (a, b) {retornar m.each (this, a, b)}, map: function (a) {retornar this.pushStack (m.map (isso, função (b, c) {return a.call (b, c, b)}))}, fatia: function () {return this.pushStack (d.apply (isto, argumentos))}, primeiro: function () { return this.eq (0)}, last: function () {retornar this.eq (-1)}, eq: function (a) {var b = este.length, c = + a + (0> a? b: 0); return this.pushStack (c> = 0 && b> c? [Este [c]]: [])}, end: function () {retornar this.prevObject || this.constructor (null)}, push: f , sort: c.sort, splice: c.splice}, m.extend = m.fn.extend = function () {var a, b, c, d, e, f, g = argumentos [0] || { }, h = 1, i = arguments.length, j =! 1, para ("boolean" == typeof g && (j = g, g = argumentos [h] || {}, h ++), "objeto" == typeof g || m.isFunction (g) || (g = {}), h === i && (g = isto, h -); i> h; h ++) se (nulo! = (e = argumentos [ h])) para (d em e) a = g [d], c = e [d], g! == c && (j && c && (m.isPlainObject (c) || ​​(b = m.isArray (c)))? (b? (b =! 1, f = a && m.isArray (a)? a: []): f = a && m.isPlainObject (a) ? a: {}, g [d] = m.extend (j, f, c)): void 0! == c && (g [d] = c)); return g}, m.extend ({expando: "jQuery" + (l + Math.random ()). substituir (/ \ D / g, ""), isReady:! 0, erro: function (a) {lançar novo erro (a)}, noop: function ( ) {}, isFunction: function (a) {retorno "function" === m.type (a)}, isArray: Array.isArray || function (a) {retorno "array" === m.type (a )}, isWindow: function (a) {return nulo! = a && a == a.window}, isNumeric: function (a) {retorno! m.isArray (a) && a-parseFloat (a)> = 0}, isEmptyObject: function (a) {var b; para (b em a) return! 1; return! 0}, isPlainObject: function (a) {var b; if (! a || "objeto"! == m.type (a ) || a.nodeType || m.isWindow (a)) return! 1; tente {if (a.constructor &&! j.call (a, "construtor") &&! j.call (a.constructor.prototype, "isPrototypeOf")) return! 1} catch (c) {retorno! 1} if (k.ownLast) para (b em a) retorno j.call (a, b); para (b em a); void 0 === b || j.call (a, b)}, tipo: function (a) {retorno null == a? a + "": "objeto" == typeof a || "function" == typeof a? h [i.call (a)] || "objeto": typeof a}, globalEval: function (b) {b && m.trim (b) && (a.execScript || function (b) {a.eval. call (a, b)}) (b)}, camelCase: function (a) {return a.replace (o, "ms -"). substitua (p, q)}, nodeName: function (a, b) { return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()}, cada: function (a, b, c) {var d, e = 0, f = comprimento, g = r (a) ; if (c) {if (g) {para (; f> e; e ++) se (d = b.apply (a [e], c), d ===! 1) quebra} mais para (e em a) se (d = b.apply (a [e], c), d ===! 1) quebra} else if (g) {para (; f> e; e ++) se (d = b.call ( a [e], e, a [e]), d ===! 1) quebra} else para (e em a) se (d = b.call (a [e], e, a [e]), d ===! 1) quebra;return a}, trim: function (a) {retorno nulo == a? "" :( a + ""). substitua (n, "")}, makeArray: function (a, b) {var c = b || []; return null! = a && (r (Objeto (a))? m.merge (c, "string" == tipoof a? [a]: a): f.call (c, a)), c} , inArray: function (a, b, c) {var d; if (b) {se (g) retorna g.call (b, a, c); para (d = b.length, c = c? 0> c? Math.max (0, d + c): c: 0; d> c; c ++) if (c em b && b [c] === a) retornar c} return-1}, mesclagem: function (a, b) {var = comprimento, d = 0, e = comprimento, enquanto (c> d) a [e +] = b [d + +]; if (c! = = c) while (void 0! == b [d]) a [e ++] = b [d ++]; retorne a.length = e, a}, grep: function (a, b, c) {para (var d, e = [], f = 0, g = a.length, h =! C; g> f; f ++) d =! B (a [f], f), d! == h && e.push (a [f]); return e}, map: function (a, b, c) {var d, f = 0, g = a.length, h = r (a), i = []; se (h) para (; g> f; f ++) d = b (a [f], f, c), nulo! = d && i.push (d); mais para (f em a) d = b (a [f], f, c), nulo! = d && i.push (d); return e.apply ([], i)}, guid: 1,proxy: função (a, b) {var c, e, f; retorno "cadeia" == tipo de b && (f = a [b], b = a, a = f), m.isFunção (a)? = d.call (arguments, 2), e = function () {return a.apply (b || isto, c.concat (d.call (argumentos)))}, e.guid = a.guid = a. guid || m.guid ++, e): void 0}, agora: function () {return + new Date}, suporte: k}), m.each ("Número da Função da Cadeia Numérica Booleana Date RegExp Object Error" .split ( ""), function (a, b) {h ["[objeto" + b + "]"] = b.toLowerCase ()}); função r (a) {var b = a.length, c = m.type (a); return "function" === c || m.isWindow (a) 1: 1 === a.nodeType && b?! 0: "array" === c || 0 === b | | "number" == typeof b && b> 0 && b-1 em uma} var s = function (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle" + - nova data, v = a.document, w = 0, x = 0, y = gb (), z = gb (), A = gb (), B = função (a, b) {retorno a === b && (l =! 0), 0}, C = "indefinido ", D = 1 << 31, E = {} hasOwnProperty, F = [], G = F.pop, H = F.push, I = F.push, J = F.slice, K = F. indexOf || function (a) {para (var b = 0, c = este.length; c> b; b ++) if (isto [b] === a) retorna b; return-1}, L = "verificado | selecionado | async | autofocus | autoplay | controles | defer | desativado | oculto | ismap | loop | múltiplo | aberto | readonly | obrigatório | escopo ", M =" [\\ x20 \\ t \\ r \\ n \\ f] ", N =" (?: \\\\. | [\\ w-] | [^ \\ x00 - \\ xa0]) + ", O = N.replace (" w "," w # "), P =" \\ ["+ M +" * ("+ N +") (?: "+ M +" * ([* ^ $ |! ~]? =) "+ M +" * (?: '( (?: \\\\. | [^ \\\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ "| ( "+ O +")) |) "+ M +" * \\] ", Q =" :( "+ N +") (?: \\ ((('((?: \\\\. | [^ \ \\\ ']) *)' | \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | ^ \\\\ () [\\]] | "+ P +") *) |. *) \\) |) ", R = new RegExp ("^ "+ M +" + | ((?: ^ | [^ \\\\]) (?: \\\\.) *) "+ M +" + $ "," g "), S = novo RegExp ( "^" + M + "*," + M + "*"), T = novo RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*"), U = new RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\] "," g "), V = novo RegExp (Q), W = novo RegExp ("^" + O + "$"), X = {ID: new RegExp ("^ # (" + N + ")"), CLASS: new RegExp ("^ \\. (" + N + ")"), TAG: novo RegExp ("^ (" + N.replace ("w", "w *") + ")"), ATTR: novo RegExp ("^" + P), PSEUDO: new RegExp ("^" + Q), CHILD: new RegExp ("^ :( apenas | primeiro | último | nth | nth-last) - (filho | do-type) (?: \\ (" + M + "* (par | ímpar | (( [+ -] |) (\\ d *) n |) "+ M +" * (?: ([+ -] |) "+ M +" * (\\ d +) |)) "+ M +" * \\ ) |) "," i "),bool: new RegExp ("^ (?:" + L + ") $", "i"), needsContext: new RegExp ("^" + M + "* [> + ~] |: (par | ímpar | eq | gt | lt | nth | first | last) (?: \\ ("+ M +" * ((?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, Y = / ^ (?: input | select | textarea | botão) $ / i, Z = / ^ h \ d $ / i, $ = / ^ [^ { ] + \ {\ s * \ [nativo \ w /, _ = / ^ (?: # ([\ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, ab = / [+ ~] /, bb = / '| \\ / g, cb = new RegExp ("\\\\ ([\\ da-f] {1,6}" + M + "? | (" + M + ") |.)", "Ig"), db = função (a, b, c) {var d = "0x" + b-65536; retorno d! == d || c? B: 0> d? String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296,1023 & d | 56320)}; tente {I.apply (F = J.call (v.childNodes), v.childNodes), F [v.childNodes.length] .nodeType} catch (eb) {I = {aplicar: F.length? Function (a, b) {Aplica-se (a, J.call (b))}: function (a b) {var c = a.length, d = 0; enquanto (a [c ++] = b [d ++]);length = c-1}}} função fb (a, b, d, e) {var f, h, j, k, l, o, r, s, w, x; if ((b? b.ownerDocument | | b: v)! == n && m (b), b = b || n, d = d || [],! a || "string"! = typeof a) retorno d; if (1! == ( k = b.nodeType) && 9! == k) return []; if (p &&! e) {if (f = _. exec (a)) if (j = f [1]) {se (9 === k) {if (h = b.getElementById (j),! h ||! h.parentNode) retorna d; se (h.id === j) retorna d.push (h), d} mais se (b .ownerDocument && (h = b.ownerDocument.getElementById (j)) && t (b, h) && h.id === j) retornar d.push (h), d} mais {if (f [2]) return I. apply (d, b.getElementsByTagName (a)), d; if ((j = f [3]) && c.getElementsByClassName && b.getElementsByClassName) return I.apply (d, b.getElementsByClassName (j)), d} if (c .qsa && (! q ||! q.test (a))) {se (s = r = u, w = b, x = 9 === k && a, 1 === k && "objeto"! == b. nodeName.toLowerCase ()) {o = g (a), (r = b.getAttribute ("id"))? s = r.replace (bb, "\\ $ &"): b.setAttribute (" id ", s), s =" [id = '"+ s +"'] ", l = o.length; enquanto (l -) o [l] = s + qb ( o [l]); w = ab.test (a) && ob (b.parentNode) || b, x = o.join (",")} se (x) try {return I.apply (d, w. querySelectorAll (x)), d} catch (y) {} finalmente {r || b.removeAttribute ("id")}}} return i (a.replace (R, "$ 1"), b, d, e) } função gb () {var a = []; função b (c, e) {retornar a.push (c + "")> d.cacheLength && excluir b [a.shift ()], b [c + ""] = e } return b} função hb (a) {return a [u] =! 0, a} função ib (a) {var b = n.createElement ("div"); tente {retornar !! a (b)} capturar (c) {return! 1} finalmente {b.parentNode && b.parentNode.removeChild (b), b = nulo}} function jb (a, b) {var = a.split ("|"), e = a. length; while (e -) d.attrHandle [c [e]] = b} função kb (a, b) {var = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType &&(~ b.sourceIndex || D) - (~ a.sourceIndex || D), se (d) retornar d; if (c) while (c = c.nextSibling) if (c === b) return-1 ; retorna uma função? 1: -1} lb (a) {função return (b) {var = b.nodeName.toLowerCase (); retorna "input" === c && b.type === a}} function mb (a) {return function (b) {var = b.nodeName.toLowerCase (); return ("input" === c || "button" === c) && b.type === a}} função nb (a) {retorno hb (função (b) {retorno b = + b, hb (função (c, d) {var e, f = a ([], c.length, b), g = f.length ; while (g -) c [e = f [g]] && (c [e] =! (d [e] = c [e]))})})} função ob (a) {retornar a && tipoof a .getElementsByTagName! == C && a} c = fb.support = {}, f = fb.isXML = função (a) {var b = a && (a.ownerDocument || a) .documentElement; devolve b? "HTML"! = b.nodeName:! 1}, m = fb.setDocument = função (a) {var b, e = a? proprietário.documento || a: v, g = e.defaultView; retorno e! == n && 9 == = e.nodeType && e.documentElement? (n = e, o = e.documentElement, p =! f (e), g && g! == g.top && (g.addEventListener? g.addEventListener ("descarregar", função () {m ()}, ! 1): g.attachEvent && g.attachEvent ("onunload", função () {m ()})), c.attributes = ib (função (a) {return a.className = "i",! A.getAttribute ( "className")}), c.getElementsByTagName = ib (função (a) {return a.appendChild (e.createComment ("")), a.getElementsByTagName ("*"). length}), c.getElementsByClassName = $ .test (e.getElementsByClassName) && ib (function (a) {retornar a.innerHTML = "<div-classe = 'a'> </ div> <div-classe = 'a i'> </ div>", a. firstChild.className = "i", 2 === a.getElementsByClassName ("i"). length}), c.getById = ib (função (a) {retorno o.appendChild (a) .id = u,! e .getElementsByName ||! e.getElementsByName (u) .length}), c.getById? (d.find.ID = função (a, b) {if (tipo de b.getElementById! == C && p) {var = b.getElementById (a); c & c.parentNode? [c]: []}}, d.filter.ID = função (a) {var b = a.replace (cb, db); função de retorno (a) {return a.getAttribute ("id" ) === b}}) :( delete d.find.ID, d.filter.ID = função (a) {var b = a.replace (cb, db); função de retorno (a) {var c = tipo de a.getAttributeNode! == C && a.getAttributeNode ("id"); return c && c.value === b}}), d.find.TAG = c.getElementsByTagName? function (a, b) {tipo de retorno de b.getElementsByTagName! == C? B.getElementsByTagName (a): void 0}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a); if ("*" == = a) {while (c = f [e ++]) 1 === c.nodeType && d.push (c); retorno d} retorno f}, d.find.CLASS = c.getElementsByClassName && function (a, b) {tipo de retorno b.getElementsByClassName! == C && p? b.getElementsByClassName (a): void 0}, r = [], q = [], (c.qsa = $. teste (e.querySelectorAll)) && (ib (function (a) {a.innerHTML = "<select msallowclip = ''> <opção selecionada = ''> </ option> </ select>", a.querySelectorAll ("[msallowclip ^ = ']"). length && q.push ("[* ^ $] = "+ M +" * (?: '' | \ "\") "), a.querySelectorAll (" [selecionado] "). Length || q.push (" \\ ["+ M +" * (?: value | "+ L +") "), a.querySelectorAll (": checked "). length || q.push (": checked ")}), ib (função (a) {var b = e.createElement (" input "); b.setAttribute (" tipo "," oculto "), a.appendChild (b) .setAttribute (" nome "," D "), a.querySelectorAll (" [nome = d] "). length && q. push ("name" + M + "* [* ^ $ |! ~]? ="),a.querySelectorAll (": enabled"). length || q.push (": enabled", ": disabled"), a.querySelectorAll ("* ,: x"), q.push (",. *:" )})), (c.matchesSelector = $. test (s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ib (function (a) {c. disconnectedMatch = s.call (a, "div"), s.call (a, "[s! = '']: x"), r.push ("! =", Q)}), q = q. length && new RegExp (q.join ("|")), r = r.length && new RegExp (r.join ("|")), b = $. teste (o.compareDocumentPosition), t = b || $ .test ( o.contains)? function (a, b) {var = 9 == = a.nodeType? a.documentElement: a, d = b && b.parentNode; retorno a === d ||! (! d || 1 ! == d.nodeType ||! (c.contains? c.contains (d): a.compareDocumentPosition && 16 & a.compareDocumentPosition (d))): function (a, b) {se (b) while (b = b.parentNode) if (b === a) retornar! 0; retornar! 1}, B = b? função (a, b) {if (a === b) retornar l =! 0,0; var d =! a.compareDocumentPosition-! b.compareDocumentPosition; return d? d: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition (a) === d? a === e || a.ownerDocument === v && t (v, a)? - 1: b === e || b.ownerDocument === v && t (v, b)? 1: k? K.call (k, a) -K.call (k, b): 0: 4 & d? -1: 1)}: funï¿½o (a, b) {se (a = == b) return l =! 0,0; var c, d = 0, f = a.parentNode, g = b.parentNode, h = [a], i = [b]; if (! f ||! g) retornar a === e? -1: b === e? 1: f? -1: g? 1: k? K.call (k, a) -K.call (k, b): 0 ; se (f === g) retornar kb (a, b); c = a; enquanto (c = c.parentNode) h.unshift (c); c = b; enquanto (c = c.parentNode) i. unshift (c); enquanto (h [d] === i [d]) d ++; retorno d? kb (h [d], i [d]): h [d] === v? -1: i [d] === v? 1: 0}, e): n}, fb.matches = função (a, b) {retorno fb (a, nulo, nulo, b)}, fb.matchesSelector = função (a b) {se ((a.ownerDocument || a)! == n && m (a), b = b.replace (U, "= '$ 1']"),! (! c.matchesSelector ||! p || r && r.test (b) || q && q.test (b))) tente {var d = s.call (a, b); se (d || c.disconnectedMatch || a.document && 11! == a.document.nodeType) retorne d} catch (e ) {} return fb (b, n, nulo, [a]). length> 0}, fb.contains = função (a, b) {retorno (a.ownerDocument || a)! == n && m (a), t (a, b)}, fb.attr = função (a, b) {(a.ownerDocument || a)! == n && m (a); var e = d.attrHandle [b.toLowerCase ()], f = e && E.call (d.attrHandle, b.toLowerCase ())? e (a, b,! p): void 0; retorne void 0! == f? f: c.attributes ||! p? a.getAttribute (f = a.getAttributeNode (b)) && f.specified? f.value: null}, fb.error = função (a) {throw new Error ("Erro de sintaxe, expressão não reconhecida:" + a)} , fb.uniqueSort = função (a) {var b, d = [], e = 0, f = 0; se (l =! c.detectDuplicates, k =! c.sortStable && a.slice (0), a.sort (B), l) {enquanto (b = a [f ++]) b === a [f] && (e = d.push (f)); enquanto (e -) a.splice (d [e ], 1)} return k = nulo, a}, e = fb.getText = função (a) {var b, c = "", d = 0, f = a.nodeTipo; if (f) {se (1 === f || 9 === f || 11 === f) {if ("string" == typeof a.textContent) retorna a.textContent; para (a = a.firstChild; a; a = a .nextSibling) c + = e (a)} else if (3 === f || 4 === f) retorna a.nodeValue} else while (b = a [d ++]) c + = e (b); retorno c }, d = fb.selectors = {cacheLength: 50, createPseudo: hb, correspondência: X, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", primeiro:! 0} , "": {dir: "parentNode"}, "+": {dir: "previousSibling", primeiro:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (a ) {return a [1] = a [1] .replace (cb, db), a [3] = (a [3] || a [4] || a [5] || "") substitua ( cb, db), "~ =" === a [2] && (a [3] = "" + a [3] + ""),a.slice (0,4)}, CHILD: function (a) {retornar a [1] = a [1] .toLowerCase (), "nth" === a [1] .slice (0,3)? (a [3] || fb.error (a [0]), a [4] = + (a [4]? a [5] + (a [6] || 1): 2 * ("mesmo" === a [3] || "ímpar" === a [3])), a [5] = + (a [7] + a [8] || "ímpar" === a [3] )): a [3] && fb.error (a [0]), a}, PSEUDO: function (a) {var b, c =! a [6] && a [2]; retorno X.CHILD.test (a [0])? Null: (a [3]? A [2] = a [4] || a [5] || "": c && V.test (c) && (b = g (c, 0) ) && (b = c.indexOf (")", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c. slice (0, b)), a.slice (0,3))}}, filtro: {TAG: função (a) {var b = a.replace (cb, db) .toLowerCase (); retorno "*" === a? function () {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASS: function (a) {var b = y [a + " "]; return b || (b = new RegExp (" (^ | "+ M +") "+ a +" ("+ M +"| $) ")) && y (a, function (a) {return b.test (" string "== tipoof a.className && a.className || tipoof a.getAttribute! == C && a.getAttribute (" class ") || "")}}}, ATTR: function (a, b, c) {função de retorno (d) {var e = fb.attr (d, a); retorno nulo == e? "! =" === b : b? (e + = "", "=" === b? e === c: "! =" === b? e! == c: "^ =" === b? c && 0 == = e.indexOf (c): "* =" === b? c && e.indexOf (c)> - 1: "$ =" === b? c && e.slice (-c.length) === c: "~ =" === b? ("" + e + "") .indexOf (c)> - 1: "| =" === b? e === c || e.slice (0, c. comprimento + 1) === c + "-" :! 1) :! 0}}, CHILD: function (a, b, c, d, e) {var = "nth"! == a.slice (0 , 3), g = "last"! == a.slice (-4), h = "do tipo" === b; return 1 === d && 0 === e? Function (a) {retorno! ! a.parentNode}: function (b, c, i) {var j, k,l, m, n, o, p = f! == g? "nextSibling": "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase (), s =! i &&! h; if (q ) {if (f) {enquanto (p) {l = b; enquanto (l = l [p]) se (h? l.nodeName.toLowerCase () === r: 1 === l.nodeType) retorno ! 1; o = p = "somente" === a &&! O && "nextSibling"} retornar! 0} if (o = [g? Q.firstChild: q.lastChild], g && s) {k = q [u] | | (q [u] = {}), j = k [a] || [], n = j [0] === w && j [1], m = j [0] === w && j [2], l = n && q.childNodes [n]; enquanto (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) if (1 === l.nodeType && ++ m && l == = b) {k [a] = [w, n, m]; quebra}} mais se (s && (j = (b [u] || (b [u] = {})) [a]) && j [ 0] === w) m = j [1]; senão enquanto (l = ++ n && l && l [p] || (m = n = 0) || o.pop ()) if ((h? L.nodeName .toLowerCase () === r: 1 === l.nodeType) && ++ m && (s && ((l [u] || (l [u] = {})) [a] = [w, m] ), l === b)) quebra; retorno m- = e,m === d || m% d === 0 && m / d> = 0}}}, PSEUDO: function (a, b) {var c, e = d.pseudos [a] || d.setFilters [a .toLowerCase ()] || fb.error ("não suportado pseudo:" + a); return e [u] e (b): e.length> 1 (c = [a, a, "", b] , d.setFilters.hasOwnProperty (a.toLowerCase ())? hb (função (a, c) {var d, f = e (a, b), g = f.length; enquanto (g -) d = K chamada (a, f [g]), a [d] =! (c [d] = f [g])}): função (a) {retorno e (a, 0, c)}): e} }, pseudos: {não: hb (função (a) {var b = [], c = [], d = h (a.replace (R, "$ 1")); retorno d [u]? hb (função (a, b, c, e) {var f, g = d (a, nulo, e, []), h = comprimento a, enquanto (h -) (f = g [h]) && (a [h] =! (b [h] = f))}): function (a, e, f) {retorno b [0] = a, d (b, nulo, f, c),! c.pop ( )}}) tem: hb (function (a) {função return (b) {return fb (a, b) .length> 0}}) contém: hb (function (a) {função return (b) { return (b.textContent || b.innerText || e (b)). indexOf (a)> - 1}}), lang: hb (função (a) {retorno W.test (a || "") | | fb.erro ("sem suporte lang:" + a), um = a.replace (cb, db) .toLowerCase (), função (b) {var c; se if (c = p? b.lang: b.getAttribute (" xml: lang ") || b.getAttribute (" lang ")) return c = c.toLowerCase (), c === a || 0 === c.indexOf (a +" - "); while ((b = b.parentNode) && 1 === b.nodeType); retorno! 1}}), target: function (b) {var = a.location && a.location.hash; retorno c && c.slice (1) === b .id}, raiz: function (a) {retorno a === o}, foco: function (a) {retorno a === n.activeElement && (! n.hasFocus || n.hasFocus ()) && !! (a.type || a.href || ~ a.tabIndex)}, ativado: function (a) {return a.disabled ===! 1}, desabilitado: function (a) {return a.disabled === ! 0}, verificado: function (a) {var b = a.nodeName.toLowerCase (); retorna "input" === b && !! a.checked || "option" === b && !! a.selected} , selecionado: function (a) {return a.parentNode && a.parentNode.selectedIndex, a.selected ===! 0}, empty: function (a) {para (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType <6) retornar! 1; retorno! 0 }, parent: function (a) {retorno! d.pseudos.empty (a)}, cabeçalho: function (a) {retorno Z.test (a.nodeName)}, entrada: function (a) {return Y.test (a.nodeName)}, botão: function (a) {var b = a.nodeName.toLowerCase (); retorna "input" === b && "button" === a.type || "button" === b}, texto: function (a) {var b; retorno "input" === a.nodeName.toLowerCase () && "text" === a.type && (null == (b = a.getAttribute ("tipo ")) ||" text "=== b.toLowerCase ())}, primeiro: nb (function () {return [0]}), ult: nb (function (a, b) {retorno [b-1 ]}), eq: nb (função (a, b, c) {retorno [0> c? c + b: c]}), mesmo: nb (função (a, b) {para (var c = 0; b> c; c + = 2) a.push (c); retorne a}), ímpar: nb (função (a, b) {para (var c = 1; b> c; c + = 2) a.push ( c); retornar a}), lt:nb (função (a, b, c) {para (var d = 0> c + c + b: c; - d> = 0;) a.push (d); retorne a}), gt: nb ( função (a, b, c) {para (var d = 0> c + c + b: c; ++ d <b;) a.push (d); retorne a}}}}, d.pseudos.nth = d.pseudos.eq; para (b em {radio:! 0, checkbox:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) d.pseudos [b] = lb (b); para (b em {enviar:! 0, redefinir:! 0}) d.pseudos [b] = mb (b); função pb () {} pb.prototype = d.filters = d.pseudos, d.setFilters = novo pb, g = fb.tokenize = função (a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; se (k) retornar b? 0: k .slice (0); h = a, i = [], j = d.preFilter; enquanto (h) {(! c || (e = S.exec (h))) && (e && (h = h. fatia (e [0] .comprimento) || h), i.push (f = [])), c =! 1, (e = T.exec (h)) && (c = e.shift (), f.push ({valor: c, tipo: e [0] .replace (R, "")}), h = h.slice (c.length)); para (g em d.filter)! (e = X [g] .exec (h)) || j [g] &&! (E = j [g] (e)) || (c = e.shift (), f.push ({valor: c, tipo : g, combinações: e}), h = h.slice (c.length)), se (! c) quebra} retorna b? h.comprimento: h? fb.error (a): z (a, i) .segmento (0)}; função qb (a) {para (var b = 0, c = comprimento a, d = ""; c> b; b ++) d + = a [b] .value; retorno d} função rb (a, b, c) {var d = b.dir, e = c && "parentNode" === d, f = x ++; retorno b primeira função (b, c, f) {enquanto (b = b [d]) se (1 === b.nodeType || e) retornar a (b, c, f)}: function (b, c g) {var h, i, j = [w, f], se (g) {enquanto (b = b [d]) se ((1 === b.nodeType || e) && a (b, c , g)) return! 0} else while (b = b [d]) if (1 === b.nodeType || e) {se (i = b [u] || (b [u] = {} ), (h = i [d]) && h [0] === w && h [1] === f) retorne j [2] = h [2]; se (i [d] = j, j [2] = a (b, c, g)) retornar! 0}}} função sb (a) {retorno a.length> 1? função (b, c, d) {var e = a.length; while (e-- ) if (! a [e] (b, c, d)) retorna! 1; retorna! 0}: a [0]} funç˜ao tb (a, b, c) {para (var d = 0, e = b .length; e> d; d ++) fb (a, b [d], c); retorno c} função ub (a, b, c, d, e) {para (var f, g = [], h = 0, i = a.length, j = null! = B; i> h; h ++) (f = a [h]) && (! C || c (f, d, e)) && (g.empurrar (f), j && b.push (h)); retorno g} função vb (a, b, c, d, e, f) {retornar d &&! d [u] && (d = vb (d)), e && ! e [u] && (e = vb (e, f)), hb (função (f, g, h, i) {var j, k, l, m = [], n = [], o = g .comprimento, p = f || tb (b || "*", h.nodeType? [h]: h, []), q =! a ||! f && b? p: ub (p, m, a, h, i), r = c? e || (f? a: o || d)? []: g: q; if (c & c (q, r, h, i), d) {j = ub ( r, n), d (j, [], h, i), k = j.length, enquanto (k -) (l = j [k]) && (r [n [k]] =! (q [n [k]] = l))} se (f) {se (e || a) {se (e) {j = [], k = r.length; enquanto (k -) (l = r [k]) &&j.push (q [k] = l); e (null, r = [], j, i)} k = r.length; enquanto (k -) (l = r [k]) && (j = e? K.call (f, l): m [k])> - 1 && (f [j] =! (g [j] = l))}} mais r = ub (r === g.splice (o, r.length): r), e? e (null, g, r, i): I.apply (g, r)})} função wb (a) {para (var b , c, e, f = comprimento, g = d.relativo [a [0] .tipo], h = g || d.relativo [""], i = g? 1: 0, k = rb ( função (a) {retornar a === b}, h,! 0), l = rb (função (a) {retornar K.call (b, a)>-1}, h,! 0), m = [função (a, c, d) {retorno! G && (d || c! == j) || ((b = c) .nodeTipo? K (a, c, d): l (a, c, d))}; f> i; i ++) se (c = d.relativo [a [i] .tipo]) m = [rb (sb (m), c )]; else {if (c = d.filter [a [i] .tipo] .apply (nulo, a [i] .matches), c [u]) {para (e = ++ i; f> e ; e ++) if (d.relativo [a [e] .tipo]) quebra; retorno vb (i> 1 && sb (m), i> 1 && qb (a.slice (0, i-1) .concat ({valor: " "=== a [i-2] .type?" * ":" "})). replace (R," $ 1 "), c, e> i && wb (a.slice (i, e)), f> e && wb (a = a.slice (e)), f> e & qb (a)}} m.push (c)} retorno sb (m)} função xb (a, b) {var = comprimento_c> 0, e = a.length> 0, f = função (f, g, h, i, k) {var l, m, o, p = 0, q = "0", r = f && [], s = [] , t = j, u = f || e && d.find.TAG ("*", k), v = w + = nulo == t? 1: Math.random () || .1, x = u.length; para (k && (j = g! == n && g); q! == x && nulo! = (l = u [q]); q ++) {se (e & l) {m = 0;while (o = a [m ++]) se (o (l, g, h)) {i.push (l); quebrar} k && (w = v)} c && ((l =! o && l) && p -, f && r .push (l)}} se (p + = q, c & | q! == p) {m = 0; enquanto (o = b [m ++]) o (r, s, g, h); se (f) {se (p> 0) enquanto (q -) r [q] || s [q] || (s [q] = G.call (i)); s = ub (s)} I.aplicar (i, s), k &&! f && s.length> 0 && p + b.length> 1 && fb.uniqueSort (i)} retorno k && (w = v, j = t), r}; retorno c? hb (f): f} retorno h = fb.compile = function (a, b) {var c, d = [], e = [], f = A [a + ""]; se (! f) {b || (b = g (a)) , c = b.length; enquanto (c -) f = wb (b [c]), f [u] d.push (f): e.push (f); f = A (a, xb ( e, d)), f.selector = a} retorno f}, i = fb.select = função (a, b, e, f) {var i, j, k, l, m, n = "função" = = typeof a && a, o =! f && g (a = n.selector || a); if (e = e || [], 1 === o.length) {se (j = o [0] = o [0 ] .slice (0), j.length> 2 && "ID" === (k = j [0]). tipo && c.getById && 9 === b.nodeType &&p && d.relative [j [1] .type]) {se (b = (d.find.ID (k.matches [0] .replace (cb, db), b) || []) [0],! b) return e; n && (b = b.parentNode), a = a.slice (j.shift (). value.length)} i = X.needsContext.test (a)? 0: j.length; i -) {if (k = j [i], d.relativo [l = k.type]) quebra; se ((m = d.find [l]) && (f = m (k.matches [0 ] .replace (cb, db), ab.test (j [0]. tipo) && ob (b.parentNode) || b))) {se (j.splice (i, 1), a = f.length && qb ( j), a) retornar I.apply (e, f), e; break}}} return (n || h (a, o)) (f, b, p, e, ab.test (a) && ob (b.parentNode) || b), e}, c.sortStable = u.split (""). ordene (B) .join ("") === u, c.detectDuplicates = !! l, m (), c.sortDetached = ib (função (a) {retorno 1 & a.compareDocumentPosition (n.createElement ("div"))}), ib (função (a) {return a.innerHTML = "<a href = '# '> </a> "," # "=== a.firstChild.getAttribute (" href ")}) || jb ("tipo | href | altura | largura ", função (a, b, c) {retorno c? void 0: a.getAttribute (b," tipo "=== b.toLowerCase ()? 1: 2)}), c .attributos && ib (function (a) {return a.innerHTML = "<input />", a.firstChild.setAttribute ("valor", ""), "" === a.firstChild.getAttribute ("valor")} ) || jb ("valor", função (a, b, c) {retorno c || "entrada"! == a.nodeName.toLowerCase ()? void 0: a.defaultValue}), ib (função (a ) {return null == a.getAttribute ("disabled")}} || jb (L, função (a, b, c) {var d; retorno c? void 0: a [b] ===! 0? b.toLowerCase () :( d = a.getAttributeNode (b)) && d.specified? d.value: null}), fb} (a); m.find = s, m.expr = s.seletores, m. expr [":"] = m.expr.pseudos, m.unique = s.uniqueSort, m.text = s.getText, m.isXMLDoc = s.isXML, m.contains = s.contains, var t = m. expr.match.needsContext, u = / ^ <(\ w +) \ s * \ /?> (?: <\ / \ 1> |) $ /, v = / ^. [^: # \ [\.,] * $ /; Função w (a, b, c) {if (m.isFunção (b)) retorno m .grep (a, função (a, d) {retorno !! b.call (a, d, a)! == c}); if (b.nodeType) retorna m.grep (a, função (a) { return a === b! == c}); if ("string" == typeof b) {se (v.test (b)) retornar m.filter (b, a, c); b = m.filter (b, a)} return m.grep (a, função (a) {return m.inArray (a, b)> = 0! == c})} m.filter = função (a, b, c) { var d = b [0]; retorno c && (a = ": not (" + a + ")"), 1 === b.length && 1 === d.nodeType? m.find.matchesSelector (d, a)? [d]: []: m.find.matches (a, m.grep (b, função (a) {retorno 1 === a.nodeType}))}, m.fn.extend ({find: function ( a) {var b, c = [], d = isto, e = d.length; se ("string"! = typeof a) retorne this.pushStack (m (a) .filter (function () {para (b) = 0; e> b; b ++) if (m.contains (d [b], isto)) return! 0})); para (b = 0; e> b; b ++) m.find (a, d [ b], c); return c = this.pushStack (e> 1? m.unique (c): c), c.selector = isto.selector? this.selector + "" + a: a, c}, filtro: function (a) {return this.pushStack (w (isto, a || [] ,! 1))}, não: function (a) { return this.pushStack (w (isto, um || [] ,! 0))}, é: function (a) {return !! w (isto, "string" == tipo de um && t.test (a)? m ( a): a || [] ,! 1) .length}}); var x, y = a.document, z = / ^ (?: \ s * (<[\ w \ W] +>) [^ >] * | # ([\ w -] *)) $ /, A = m.fn.init = função (a, b) {var c, d; if (! a) retorna isto; if ("string" == typeof a) {if (c = "<" === a.charAt (0) && ">" === a.charAt (a.length-1) && a.length> = 3? [null, a , null]: z.exec (a),! c ||! c [1] && b) return! b || b.jquery? (b || x) .find (a): este.construtor (b). find (a); if (c [1]) {if (b = b instanceof m? b [0]: b, m.merge (isso, m.parseHTML (c [1], b && b.nodeType? b.ownerDocument || b: y,! 0)), u.test (c [1]) && m.isPlainObject (b)) para (c em b) m.isFunção (este [c])? este [c] (b [ c]): this.attr (c, b [c]);return this} if (d = y.getElementById (c [2]), d && d.parentNode) {if (d.id! == c [2]) return x.find (a); this.length = 1, isto [0] = d} retornar this.context = y, this.selector = a, this} retornar a.nodeType? (This.context = this [0] = a, this.length = 1, isso): m.isFunction (a)? "indefinido"! = tipo de x.ready? x.ready (a): a (m) :( void 0! == a.selector && (this.selector = a.selector, this.context = a. context), m.makeArray (a, this))}; A.prototype = m.fn, x = m (y); var B = / ^ (?: pais | prev (?: Até | Todos)) /, C = {filhos:! 0, conteúdo:! 0, próximo:! 0, prev:! 0}; m.extend ({dir: função (a, b, c) {var d = [], e = a [ b]; while (e && 9! == e.nodeType && (void 0 === c || 1! == e.nodeType ||! m (e) .é (c))) 1 === e.nodeType && d. push (e), e = e [b]; return d}, irmão: function (a, b) {para (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! = = b && c.push (a); retorno c}}), m.fn.extend ({tem: function (a) {var b, c = m (a, isto), d = c.length;return this.filter (function () {para (b = 0; d> b; b ++) if (m.contains (isso, c [b])) return! 0})}, mais próximo: function (a, b) {para (var c, d = 0, e = este.length, f = [], g = t.test (a) || "string"! = tipo de a? m (a, b || this.context) : 0; e> d; d ++) para (c = este [d]; c & c = c = c = c.parentNode) if (c.nodeType <11 && (g? G.index (c)> - 1: 1 === c.nodeType && m.find.matchesSelector (c, a))) {f.push (c); break} retornar this.pushStack (f.length> 1? M.unique (f): f)}, index: function (a) {return a? "string" == typeof a? m.inArray (este [0], m (a)): m.inArray (a.jquery? a [0]: a, isto) : this [0] && this [0] .parentNode? this.first (). prevAll (). length: -1}, adicionar: function (a, b) {retornar this.pushStack (m.unique (m.merge) this.get (), m (a, b))))}, addBack: function (a) {retornar this.add (null == a? this.prevObject: this.prevObject.filter (a))}}) ; função D (a, b) {fazer a = a [b]; while (a && 1! == a.nodeType); retornar a} m.each ({parent: function (a) {var b = a.parentNode; retorno b && 11! == b.nodeType? b: null}, pais: function (a) {retorno m.dir (a, "parentNode")} , parentsUntil: function (a, b, c) {return m.dir (a, "parentNode", c)}, next: function (a) {retorno D (a, "nextSibling")}, prev: function (a ) {return D (a, "previousSibling")}, nextAll: function (a) {return m.dir (a, "nextSibling")}, prevAll: function (a) {retorno m.dir (a, "previousSibling" )}, nextUntil: function (a, b, c) {return m.dir (a, "nextSibling", c)}, prevUntil: function (a, b, c) {retorno m.dir (a, "previousSibling" , c)}, irmãos: function (a) {return m.sibling ((a.parentNode || {}). firstChild, a)}, filhos: function (a) {return m.sibling (a.firstChild)} , conteúdo: function (a) {retorno m.nodeName (a, "iframe")? a.contentDocument || a.contentWindow.document: m.merge ([], a.childNodes)}},function (a, b) {m.fn [a] = função (c, d) {var e = m.map (isto, b, c); retorno "Até"! == a.slice (-5) && (d = c), d && "string" == typeof d && (e = m.filter (d, e)), this.length> 1 && (C [a] || (e = m.unique (e)), B.test (a) && (e = e.reverse ())), this.pushStack (e)}}); var E = / \ S + / g, F = {}; função G (a) {var = F [a] = {}; retorno m.each (a.match (E) || [], function (a, c) {b [c] =! 0}), b} m.Callbacks = function ( a) {a = "string" == typeof a? F [a] || G (a): m.extend ({}, a); var b, c, d, e, f, g, h = [ ], i =! a.once && [], j = função (l) {para (c = a.memória && l, d =! 0, f = g || 0, g = 0, e = h.length, b = ! 0; h && e> f; f ++) if (h [f] .aplicar (l [0], l [1]) ===! 1 && a.stopOnFalse) {c =! 1; quebra} b =! 1, h && (i? i.length &&j (i.shift ()): c? h = []: k.disable ())}, k = {adicionar: funo () {if (h) {var d = h.length; ! função f (b) {m.each (b, função (b, c) {var d = tipo m (c); "função" === d? a.unique &&k.has (c) || ​​h.push (c): c && c.length && "string"! == d && f (c)})} (argumentos), b? e = h.length: c && (g = d, j (c)} return this}, remove: function () {return h && m.each (argumentos, função (a, c) {var d; enquanto ((d = m.inArray (c, h, d))> - 1) h.splice (d, 1), b && (e> = d && e -, f> = d && f -)}), isto}, tem: function (a) {return a? M.inArray (a, h )> - 1:! (! H ||! H.length)}, vazio: function () {retorno h = [], e = 0, isto}, desabilitado: function () {return h = i = c = void 0, this}, disabled: function () {return! h}, lock: function () {retorno i = void 0, c || k.disable (), este}, bloqueado: function () {return! i }, fireWith: function (a, c) {retorno! h || d &&! i || (c = c || [], c = [a, c.slice? c.slice (): c], b? i.push (c): j (c)), isto}, fogo: function () {return k.fireWith (isto, argumentos), isto}, disparou: function () {return !! d}}; }, m.extend ({Deferred: function (a) {var b = [["resolve "," done ", m.Callbacks (" once memory ")," resolvido "], [" reject "," fail ", m.Callbacks (" once memory ")," rejeitado "], [" notificar " , "progresso", m.Callbacks ("memória")]], c = "pendente", d = {estado: function () {retorno c}, sempre: function () {return e.done (argumentos) .fail (argumentos), isto}, então: function () {var a = argumentos; return m.Deferred (função (c) {m.each (b, função (b, f) {var g = m.isFunction (a [ b]) && a [b]; e [f [1]] (function () {var a = g && g.apply (isto, argumentos); a && m.isFunction (a.promise)? a.promise (). done (c .resolve) .fail (c.reject) .progress (c.notify): c [f [0] + "com"] (isto === d? c.promise (): isto, g? [a]: argumentos)})}), a = null}). promise ()}, promessa: function (a) {return null! = a? m.extend (a, d): d}}, e = {}; d.pipe = d.then, m.each (b, função (a,f) {var g = f [2], h = f [3]; d [f [1]] = g.add, h && g.add (function () {c = h}, b [1 ^ a] [ 2] .disable, b [2] [2] .lock), e [f [0]] = function () {retorno e [f [0] + "com"] (isto === e? D: este , argumentos), isto}, e [f [0] + "com"] = g.fireWith}), d.promise (e), a && a.call (e, e), e}, quando: function (a) {var b = 0, c = d.call (argumentos), e = c.length, f = 1! == e || a && m.isFunction (a.promise)? e: 0, g = 1 === f ? a: m.Deferred (), h = função (a, b, c) {função de retorno (e) {b [a] = isto, c [a] = argumentos.length> 1? d.call (argumentos) : e, c === i? g.notifyWith (b, c): - f || g.resolveWith (b, c)}}, i, j, k; if (e> 1) para (i = novo Matriz (e), j = novo Matriz (e), k = novo Matriz (e); e> b; b ++) c [b] && m.isFunção (c [b] .promise)? c [b] .promise () .done (h (b, k, c)) .fraude (g.reject) .progress (h (b, j, i)): - f; return f || g.resolveWith (k, c) , g.promise ()}}); var H; m.fn.ready = function (a) {retorno m.ready.promise (). done (a), isto}, m.extend ({isReady:! 1 pronto:1, holdReady: function (a) {a? M.readyWait ++: m.ready (! 0)}, pronto: function (a) {if (a ===! 0?! - m.readyWait:! M. isReady) {if (! y.body) retorna setTimeout (m.ready); m.isReady =! 0, a! ==! 0 && - m.readyWait> 0 || (H.resolveWith (y, [m] ), m.fn.triggerHandler && (m (y) .triggerHandler ("pronto"), m (y) .off ("pronto")))}}}) função I () {y.addEventListener? (y. removeEventListener ("DOMContentLoaded", J,! 1), a.removeEventListener ("carregar", J,! 1)) :( y.detachEvent ("onreadystatechange", J), a.detachEvent ("onload", J)) } function J () {(y.addEventListener || "load" === event.type || "completo" === y.readyState) && (I (), m.ready ())} m.ready. promessa = function (b) {if (! H) if (H = m.Deferred (), "complete" === y.readyState) setTimeout (m.ready); caso contrário, (y.addEventListener) y.addEventListener ( "DOMContentLoaded", J,! 1), a.addEventListener ("load", J,! 1); senão {y.attachEvent ("onreadystatechange", J), a.attachEvent ("onload", J); var c =! 1; tente {c = null == a .frameElement && y.documentElement} catch (d) {} ​​c && c.doScroll &&! function e () {if (! m.isReady) {try {c.doScroll ("left")} captura (a) {retorno setTimeout (e, 50 }} I (), m.ready ()}} ()} return H.promise (b)}; var K = "indefinido", L; para (L em m (k)) quebra; k.ownLast = " 0 "! == L, k.inlineBlockNeedsLayout =! 1, m (função () {var a, b, c, d; c = y.getElementsByTagName (" corpo ") [0], c && c.style && (b = y .createElement ("div"), d = y.createElement ("div"), d.style.cssText = "posição: absoluto; limite: 0; largura: 0; altura: 0; topo: 0; esquerdo: -9999px ", c.appendChild (d) .appendChild (b), tipo de b.style.zoom! == K && (b.style.cssText =" display: inline; margem: 0; border: 0;padding: 1px; largura: 1px; zoom: 1 ", k.inlineBlockNeedsLayout = a = 3 === b.offsetWidth, um && (c.style.zoom = 1)), c.removeChild (d))}), função () {var a = y.createElement ("div"); if (null == k.deleteExpando) {k.deleteExpando =! 0; tente {excluir a.test} catch (b) {k.deleteExpando =! 1 }} a = null} (), m.acceptData = function (a) {var b = m.noData [(a.nodeName + "") .toLowerCase ()], c = + a.nodeType || 1; retorno 1 ! == c && 9! == c?! 1:! b || b! ==! 0 && a.getAttribute ("classid") === b}; var M = / ^ (?: \ {[\ w \ W ] * \} | \ [[w \ W] * \]) $ /, N = / ([AZ]) / g; função O (a, b, c) {se (vazio 0 === c && 1 = == a.nodeType) {var d = "dados -" + b.replace (N, "- $ 1"). toLowerCase (); if (c = a.getAttribute (d), "string" == typeof c) {try {c = "true" === c? 0: "false" === c?! 1: "null" === c? null: + c + "" === c? + c: M .test (c)? m.parseJSON (c): c} captura (e) {} m.data (a, b,c)} sen c = void 0} return c} funç˜ao P (a) {var b; para (b em a) if (("dados"! == b ||! m.isEmptyObject (a [b])) && "toJSON"! == b) return! 1; return! 0} função Q (a, b, d, e) {se (m.acceptData (a)) {var f, g, h = m.expando, i = a.nodeType, j = i? m.cache: a, k = i? a [h]: a [h] && h;
if (k &&j [k] && (e || j [k] .data) || void 0! == d || "string"! = typeof b) retorno k || (k = i? a [h] = c.pop () || m.guid ++: h), j [k] || (j [k] = i? {}: {toJSON: m.noop}), ("objeto" == typeof b || "function" == typeof b) && (e? j [k] = m.extend (j [k], b): j [k] .data = m.extend (j [k] .data, b)) , g = j [k], e || (g.data || (g.data = {}), g = g.data), void 0! == d && (g [m.camelCase (b)] = d), "string" == typeof b? (f = g [b], null == f && (f = g [m.camelCase (b)])): f = g, f}} função R (a, b, c) {se (m.acceptData (a)) {var d, e f = a.nodeType, g = f? m.cache: a, h = f? a [m.expando]: m.expando ; if (g [h]) {se (b && (d = c? g [h]: g [h] .data)) {m.isArray (b)? b = b.concat (m.map (b, m.camelCase)): b em d? b = [b]: (b = m.camelCase (b), b = b em d? [b]: b.split ("")), e = b.length ; while (e -) delete d [b [e]]; se (c?! P (d):! m.isEmptyObject (d)) return} (c || (excluir g [h] .data, P (g [h]))) && (f? m.cleanData ([a], 0): k.deleteExpando || g! = g.window? delete g [h]: g [h] = null)}}} m.extend ({cache: {}, noData: {"applet":! 0, "embed": ! 0, "objeto": "clsid: D27CDB6E-AE6D-11cf-96B8-444553540000"}, hasData: function (a) {retornar a = a.nodeType? M.cache [a [m.expando]]: a [ m.expando], !! a &&! P (a)}, dados: function (a, b, c) {retorno Q (a, b, c)}, removeData: função (a, b) {retorno R (a , b)}, _ dados: function (a, b, c) {retorno Q (a, b, c,! 0)}, _ removeData: function (a, b) {retorno R (a, b,! 0)} }), m.fn.extend ({dados: função (a, b) {var c, d, e, f = isto [0], g = f && f.atributos; se (vazio 0 === a) {se (this.length && (e = m.data (f), 1 === f.nodeType &&! m._data (f, "parsedAttrs"))) {c = g.length; enquanto (c -) g [c ] && (d = g [c] .nome, 0 === d.indexOf ("dados -") && (d = m.camelCase (d.slice (5)), O (f, d, e [d ]))); m._data (f, "parsedAttrs",! 0)} return e} retornar "objeto"== typeof a? this.each (function () {m.data (isto, um)}): arguments.length> 1? this.each (function () {m.data (isto, a, b)}) : f? O (f, a, m.data (f, a)): void 0}, removeData: function (a) {retornar this.each (function () {m.removeData (this, a)})} }), m.extend ({fila: function (a, b, c) {var d; retorna a? (b = (b || "fx") + "fila", d = m._data (a, b ), c && (! d || m.isArray (c)? d = m._data (a, b, m.makeArray (c)): d.push (c)), d || []): void 0 }, dequeue: function (a, b) {b = b || "fx"; var c = m.queue (a, b), d = c.length, e = c.shift (), f = m. _queueHooks (a, b), g = função () {m.dequeue (a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" = == b && cunshift ("inprogress"), delete f.stop, e.call (a, g, f)),! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; retorna m._data (a, c) || ​​m._data (a, c, {vazio: m.Callbacks ("uma vez memória "). add (function () {m._removeData (a, b +" fila "), m._removeData (a, c)})})}}), m.fn.extend ({queue: function ( a, b) {var = 2; return "string"! = tipo de a && (b = a, a = "fx", c-), arguments.length <c? m.queue (este [0], um ): void 0 === b? isto: this.each (function () {var c = m.queue (isto, a, b); m._queueHooks (isto, a), "fx" === a && " inprogress "! == c [0] && m.dequeue (isso, a)})}, dequeue: function (a) {retornar this.each (function () {m.dequeue (this, a)})}, clearQueue : function (a) {retornar this.queue (a || "fx", [])}, promessa: function (a, b) {var c, d = 1, e = m.Deferred (), f = this , g = this.length, h = função () {- d || e.resolveWith (f, [f])}; "string"! = tipo de um && (b = a, a = void 0), a = a || "fx"; enquanto (g -) c = m._data (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty.add (h)); retorno h () e.promessa (b)}}); var S = / [+ -]? (?: \ d \ \ | |) \ d + (?: [eE] [+ -]? \ d + |) /. source, T = ["Top", "Right", "Bottom", "Left"], U = função (a, b) {return a = b || a, "nenhum" === m.css (a, "display" ) ||! m.contains (a.ownerDocument, a)}, V = m.acesso = função (a, b, c, d, e, f, g) {var h = 0, i = a.length, j = null == c; if ("objeto" === m.type (c)) {e =! 0; para (h em c) m.access (a, b, h, c [h],! 0, f, g)} else if (void 0! == d && (e =! 0, m.isFunction (d) || (g =! 0), j && (g? (B.call (a, d) , b = null): (j = b, b = função (a, b, c) {retorno j.call (m (a), c)})), b)) para (; i> h; h ++) b (a [h], c, g d d: d.call (a [h], h, b (a [h], c))); return e a a: j b b.call (a): i? b (a [0], c): f}, W = / ^ (?: caixa de verificação | rádio) $ / i;! function () {var a = y.createElement ("entrada"), b = y .createElement ("div"), c = y.createDocumentFragment (); if (b.innerHTML = "<link /> <tabela> </ table> <a href = '/ a'> a </a> <input type = 'checkbox' /> ", k.leadingWhitespace = 3 === b.firstChild.nodeType, k.tbody =! b.getElementsByTagName (" tbody "). comprimento, k.htmlSerializar = !! b.getElementsByTagName ("link"). length, k.html5Clone = "<: nav> </: nav>"! == y.createElement ("nav"). cloneNode (! 0) .outerHTML, um .type = "checkbox", a.checked =! 0, c.appendChild (a), k.appendChecked = a.checked, b.innerHTML = "<textarea> x </ textarea>", k.noCloneChecked = !! b.cloneNode (! 0) .lastChild.defaultValue, c.appendChild (b), b.innerHTML = "<tipo de entrada = 'rádio' verificado = 'verificado' nome = 't' />", k.checkClone = b .cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, k.noCloneEvent =! 0, b.attachEvent && (b.attachEvent ("onclick", função () {k.noCloneEvent =! 1}), b .cloneNode (! 0) .click ()),null == k.deleteExpando) {k.deleteExpando =! 0; tente {excluir b.test} catch (d) {k.deleteExpando =! 1}}} (), function () {var b, c, d = y.createElement ("div"); para (b em {enviar:! 0, alterar:! 0, focusin:! 0}) c ​​= "ligado" + b, (k [b + "Bolhas"] = c em um ) || (d.setAttribute (c, "t"), k [b + "Bolhas"] = d.atributos [c] .expando ===! 1); d = nulo} (); var X = / ^ (?: input | select | textarea) $ / i, Y = / ^ tecla /, Z = / ^ (?: mouse | ponteiro | contextmenu) | clique /, $ = / ^ (?: focusinfocus | focusoutblur) $ / , _ = / ^ ([^.] *) (?: \. (. +) |) $ /; função ab () {retorno! 0} função bb () {retorno! 1} função cb () {tentativa {return y.activeElement} catch (a) {}} m.event = {global: {}, adicione: function (a, b, c, d, e) {var f, g, h, i, j, k , l, n, o, p, q, r = m._data (a); if (r) {c.handler && (i = c, c = i.handler, e = i.selector), c.guid | | (c.guid = m.guid ++), (g = r.eventos) || (g = r.eventos = {}), (k = r.handle) || (k = r.handle = function (a ) {return typeof m === K || a && m.event.triggered === a.type? void 0: m.event.dispatch.apply (k.elem, argumentos)}, k.elem = a), b = (b || ""). correspondência (E) || [""], h = b.length, enquanto (h -) f = _. exec (b [h]) || [], o = q = f [1], p = (f [2] | | ""). split ("."). sort (), o && (j = m.event.special [o] || {}, o = (e? j.delegateType: j.bindType) || o, j = m.event.special [o] || {}, l = m.extend ({tipo: o, origType: q, dados: d, manipulador: c, guid: c.guid, seletor: e, needsContext: e && m.expr.match.needsContext.test (e), espaço de nomes: p.join (".")}, i), (n = g [o]) || (n = g [o] = [], n .delegateCount = 0, j.setup && j.setup.call (a, d, p, k)! ==! 1 || (a.addEventListener? a.addEventListener (o, k,! 1): a.attachEvent && a.attachEvent ("on" + o, k))), j.add && (j.add.call (a, l), l.handler.guid || (l.handler.guid = c.guid)), e? n .splice (n.delegateCount ++, 0, l): n.push (l), m.event.global [o] =! 0); a = null}}, remove: function (a, b, c, d, e) {var f, g, h,i, j, k, l, n, o, p, q, r = m.hasData (a) && m._data (a); if (r && (k = r.eventos)) {b = (b || " ") .match (E) || [" "], j = b.length; while (j -) se (h = _. exec (b [j]) || [], o = q = h [ 1], p = (h [2] || ""). Split ("."). Sort (), o) {l = m.evento.special [o] || {}, o = (d? l.delegateType: l.bindType) || o, n = k [o] || [], h = h [2] && new RegExp ("(^ | \\.)" + p.join ("\\. (?:. * \\. |) ") +" (\\. | $) "), i = f = n.length; enquanto (f -) g = n [f],! e && q! == g.origType || c && c.guid! == g.guid || h &&! h.test (g.namespace) || d && d! == g.selector && ("**"! == d ||! g.selector ) || (n.splice (f, 1), g.selector && n.delegateCount -, l.remove &&l.remove.call (a, g)); i &&! n.length && (l.teardown && l.teardown.call (a , p, r.handle)! ==! 1 || m.removeEvent (a, o, r.handle), exclua k [o])} mais para (o em k) m.event.remove (a, o + b [j], c, d,! 0);m.isEmptyObject (k) && (excluir r.handle, m._removeData (a, "eventos"))}}, disparador: function (b, c, d, e) {var f, g, h, i, k , l, n, o = [d || y], p = j.call (b, "tipo")? b.type: b, q = j.call (b, "espaço de nomes")? b.namespace. split ("."): []; if (h = l = d = d || y, 3! == d.nodeType && 8! == d.nodeType &&! $. test (p + m.event.triggered) && (p.indexOf (".")> = 0 && (q = p.split ("."), p = q.shift (), q.sort ()), g = p.indexOf (":") < 0 && "on" + p, b = b [m.expando]? B: novo m.Evento (p, "objeto" == tipo de b && b), b.isTrigger = e? 2: 3, b.namespace = q. join ("."), b.namespace_re = b.namespace? new RegExp ("(^ | \\.)" + q.join ("\\. (?:. * \\. |)") + " (\\. | $) "): null, b.result = void 0, b.target || (b.target = d), c = null == c? [b]: m.makeArray (c, [ b]), k = m.event.special [p] || {}, e ||! k.trigger || k.trigger.aplique (d, c)! ==! 1)) {if (! e &&! k.noBubble &&! m.isWindow (d)) {para (i = k.delegateType || p, $. test (i + p) || (h = h.parentNode); h; h = h.parentNode) o.push (h), l = h; l === (d.ownerDocument || y) && o.push (l.defaultView || l.parentWindow || a)} n = 0; while ((h = o [n ++]) &&! b.isPropagationStopped ()) b.type = n> 1? i: k.bindType || p, f = ( m._data (h, "eventos") || {}) [b.type] && m._data (h, "manipular"), f && f.apply (h, c), f = g && h [g], f && f.apply && m .acceptData (h) && (b.result = f.apply (h, c), b.result ===! 1 && b.preventDefault ()); if (b.type = p,! e &&! b.isDefaultPrevented () && (! k._default || k._default.apply (o.pop (), c) ===! 1) && m.acceptData (d) && g && d [p] &&! m.isWindow (d)) {l = d [g], l && (d [g] = nulo), m.event.triggered = p; tente {d [p] ()} capturar (r) {} m.event.triggered = void 0, l &&(d [g] = l)} retorno b.result}}, despacho: function (a) {a = m.event.fix (a); var b, c, e, f, g, h = [], i = d.call (argumentos), j = (m._data (isso, "eventos") || {}) [a.type] || [], k = m.event.special [a.type] | | {}; if (i [0] = a, a.delegateTarget = isto,! k.preDispatch || k.preDispatch.call (isto, a)! ==! 1) {h = m.event.handlers. chamada (isto, a, j), b = 0; enquanto ((f = h [b ++]) &&! a.isPropagationStopped ()) {a.currentTarget = f.elem, g = 0; enquanto ((e = f .handlers [g ++]) &&! a.isImmediatePropagationStopped ()) (! a.namespace_re || a.namespace_re.test (e.namespace)) && (a.handleObj = e, a.data = e.data, c = ((m.event.special [e.origType] || {}). handle || e.handler) .apply (f.elem, i), void 0! == c && (a.result = c) == =! 1 && (a.preventDefault (), a.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (isto, a), a.result}}, manipuladores: function (a, b) {var c, d, e, f, g = [], h = b.delegateCount, i = a.target; if (h &&i.nodeType && (! a.button || "click"! == a.type)) para (; i! = this; i = i.parentNode || this) if (1 === i.nodeType && (i. disabled! ==! 0 || "click"! == a.type)) {para (e = [], f = 0; h> f; f ++) d = b [f], c = d.selector + " ", void 0 === e [c] && (e [c] = d.needsContext? m (c, isto) .index (i)> = 0: m.find (c, isto, null, [i] ) .Comprimento), e [c] && e.push (d); e.length &&g.push ({elem: i, manipuladores: e})} retornar h <b.length && g.push ({elem: this, handlers: b .slice (h)}), g}, correção: function (a) {if (a [m.expando]) retornar a; var b, c, d, e = a.type, f = a, g = this .fixHooks [e]; g || (this.fixHooks [e] = g = Z.test (e)? this.mouseHooks: Y.test (e)? this.keyHooks: {}), d = g.props this.props.concat (g.props): this.props, a = novo m.Evento (f), b = d.length, enquanto (b -) c = d [b], a [c] = f [c]; return a.target || (a.target = f.srcElement || y), 3 === a.target.nodeType && (a.target = a.target.parentNode), a.metaKey =! !uma.metaKey, g.filter? g.filter (a, f): a}, adereços: "bolhas altKey canceláveis ​​ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey destino timeStamp view que" .split (""), fixHooks: {}, keyHooks: { adereços: "char charCode key keyCode" .split (""), filter: function (a, b) {retorno null == a.which && (a.which = null! = b.charCode? b.charCode: b.keyCode ), a}}, mouseHooks: {props: "botões de botões clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement" .split (""), filter: function (a, b) {var c, d, e, f = b.button, g = b.fromElement; return null == a.pageX && null! = b.clientX && (d = a.target.ownerDocument || y, e = d.documentElement, c = d.body, a.pageX = b.clientX + (e& e.scrollLeft || c && c.scrollLeft || 0) - (e & e.clientLeft || c && c.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || c && c.scrollTop || 0) - (e && e.clientTop || c && c.clientTop || 0)) ,! a.relatedTarget && g && (a.relatedTarget = g === a.target?b.toElement:g), a.which || void 0 === f || (a.which = 1 & f? 1: 2 & f? 3: 4 & f? 2: 0), um}}, especial: {load: {noBubble:! 0}, foco : {trigger: function () {if (this! == cb () && this.focus) tente {return this.focus (),! 1} capturar (a) {}}, delegateType: "focusin"}, desfoque: {trigger: function () {return this === cb () && this.blur? (this.blur () ,! 1): void 0}, delegateType: "focusout"}, clique em: {trigger: function () { return m.nodeName (this, "input") && "checkbox" === this.type && this.click? (this.click () ,! 1): void 0}, _ default: function (a) {retorno m.nodeName (a.target, "a")}}, beforeunload: {postDispatch: função (a) {void 0! == a.result && a.originalEvent && (a.originalEvent.returnValue = a.result)}}}, simula: function (a, b, c, d) {var e = m.extend (novo m.Event, c, {type: a, isSimulado:! 0, originalEvent: { }}); d? m.event.trigger (e, null, b): m.event.dispatch.call (b, e), e.isDefaultPrevented () && c.preventDefault ()}}, m.removeEvent = y .removeEventListener? function (a, b, c) {a.removeEventListener && a.removeEventListener (b, c,! 1)}: function (a, b, c) {var d = "on" + b; a.detachEvent && (tipo de a [d] === K && (a [d] = nulo), a.detachEvent (d, c)}}, m.Evento = function (a, b) {retornar esta instância de m.Event? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue ===! 1? ab: bb): this.type = a, b && m.extend (this, b), this.timeStamp = a && a.timeStamp || m.now (), void (este [m.expando] =! 0)): novo m.Event (a, b)} , m.Event.prototype = {isDefaultPrevented: bb,isPropagationStopped: bb, isImmediatePropagationStopped: bb, prevent Padrão: function () {var a = this.originalEvent; this.isDefaultPrevented = ab, a && (a.preventDefault? a.preventDefault (): a.returnValue =! 1)}, stopPropagation: function () {var a = this.originalEvent; this.isPropagationStopped = ab, a && (a.stopPropagation && a.stopPropagation (), a.cancelBubble =! 0)}, stopImmediatePropagation: function () {var a = este.originalEvento; .isImmediatePropagationStopped = ab, a && a.stopImmediatePropagation && a.stopImmediatePropagation (), this.stopPropagation ()}}, m.each ({mouseenter: "mouseover", mouseleave: "mouseout", ponteiroenter: "ponteiro invertido", ponteirolinha: "ponteiroout"} , função (a, b) {m.event.special [um] = {delegateType: b, bindType: b, identificador: function (a) {var c, d = isso, e = a.relatedTarget, f = a. handleObj; return (! e || e! == d &&!m.contains (d, e)) && (a.type = f.origType, c = f.handler.apply (isto, argumentos), a.type = b), c}}}), k.submitBubbles || (m.event.special.submit = {setup: function () {return m.nodeName (this, "form")? 1: void m.event.add (isto, "click._submit keypress._submit", função (a) {var b = a.target, c = m.nodeName (b, "entrada") || m.nodeName (b, "botão")? b.form: void 0; c &&! m._data (c , "submitBubbles") && (m.event.add (c, "submit._submit", função (a) {a._submit_bubble =! 0}), m._data (c, "submitBubbles",! 0))} )}, postDispatch: function (a) {a._submit_bubble && (excluir a._submit_bubble, this.parentNode &&! a.isTrigger && m.event.simulate ("enviar", this.parentNode, a,! 0))}, teardown: function () {return m.nodeName (this, "form")? 1: void m.event.remove (this, "._ submit")}}), k.changeBubbles || (m.event.special.change = {setup: function () {retornar X.test (this.nodeName)? (("checkbox" === this.type || "radio" === isto. type) && (m.event.add (isto, "propertychange._change", function (a) {"verificado" === a.originalEvent.propertyName && (this._just_changed =! 0)}), m.event.add (isso, "click._change", função (a) {this._just_changed &&! a.isTrigger && (this._just_changed =! 1), m.event.simulate ("mudança", isto, a,! 0)})) ,! 1): void m.event.add (isso, "beforeactivate._change", function (a) {var b = a.target; X.test (nnode b.node) &&! M._data (b, "changeBubbles ") && (m.event.add (b," change._change ", função (a) {! this.parentNode || a.isSimulated || a.isTrigger || m.event.simulate (" mudança ", esta .parentNode, a,! 0)}), m._data (b, "changeBubbles",! 0))})},handle: function (a) {var b = a.target; devolva isto! == b || a.isSimulado || a.isTrigger || "radio"! == b.type && "checkbox"! == b.type ? a.handleObj.handler.apply (isto, argumentos): void 0}, teardown: function () {retorna m.event.remove (isto, "._ change"),! X.test (this.nodeName)}} ), k.focusinBubbles || m.each ({focus: "focus", blur: "focusout"}, função (a, b) {var = função (a) {m.event.simulate (b, a. target, m.event.fix (a) ,! 0)}; m.event.special [b] = {configuração: function () {var d = this.ownerDocument || isto, e = m._data (d, b); e || d.addEventListener (a, c, 0), m._data (d, b, (e || 0) +1)}, desmontagem: function () {var d = this.ownerDocument | | isto, e = m._data (d, b) -1; e? m._data (d, b, e): (d.removeEventListener (a, c,! 0), m._removeData (d, b) )}}}), m.fn.extend ({on: function (a, b, c, d, e) {var f, g; if ("objeto" == tipo de a) {"string"! = typeof b && (c = c || b, b = void 0);para (f em a) this.on (f, b, c, a [f], e); retorne isto} if (null == c && null == d? (d = b, c = b = void 0): null == d && ("string" == typeof b? (d = c, c = void 0): (d = c, c = b, b = void 0)), d ===! 1) d = bb ; senão se (! d) retornar isto; return 1 === e && (g = d, d = função (a) {retorno m (). off (a), g.apply (isto, argumentos)}, d. guid = g.guid || (g.guid = m.guid ++)), this.each (function () {m.event.add (isto, a, d, c, b)})}, um: function ( a, b, c, d) {retornar this.on (a, b, c, d, 1)}, off: função (a, b, c) {var d, e; if (a && a.preventDefault && a.handleObj) return d = a.handleObj, m (a.delegateTarget) .off (d.namespace? d.origType + "." + d.namespace: d.origType, d.selector, d.handler), isto; if ("objeto "== typeof a) {para (e em a) this.off (e, b, a [e]); retorne isto} return (b ===! 1 ||" function "== typeof b) && ( c = b, b = void 0), c ===! 1 && (c = bb), this.each (função () {m.event.remove (isto, a, c, b)})},trigger: function (a, b) {retornar this.each (function () {m.event.trigger (a, b, this)})}, triggerHandler: function (a, b) {var = esta [0] ; retorna c? m.event.trigger (a, b, c,! 0): void 0}}); função db (a) {var b = eb.split ("|"), c = a.createDocumentFragment ( ); if (c.createElement) while (b.length) c.createElement (b.pop ()); retorno c} var eb = "abr | | article | aparte | audio | bdi | canvas | data | datalist | detalhes | figcaption | figura | rodapé | cabeçalho | hgroup | marca | medidor | nav | saída | progresso | seção | resumo | hora | vídeo ", fb = / jQuery \ d + =" (?: null | \ d +) "/ g, gb = new RegExp ("<(?:" + eb + ") [\\ s />]", "i"), hb = / ^ \ s + /, ib = / <(área ?! | br | col | embed | h | img | entrada | link | meta | param) (([\ w:] +) [^>] *) \ /> / gi, jb = / <([\ w:] +) /, kb = / <tbody / i, lb = / <& & #? \ w +; /, mb = / <(?: script | estilo | link) / i, nb = / verificado \ s * (?: [^ =] | = \ s * .checked.) / i, ob = / ^ $ | \ / (?: java | ecma) script / i,pb = / ^ verdadeiro \ / (. *) /, qb = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g, rb = {opção: [1, "<select multiple = 'multiple'>", "</ select>"], legenda: [1, "<fieldset>", "</ fieldset>"], area: [1, "<map>", "</ map>"], param: [1, "<objeto>", "</ objeto>"], thead: [1, "<tabela>", " </ table> "], tr: [2," <tabela> <tbody> "," </ tbody> </ table> "], col: [2," <tabela> <tbody> </ tbody> < colgroup> "," </ colgroup> </ table> "], td: [3," <tabela> <tbody> <tr> "," </ tr> </ tbody> </ table> "], _ padrão : k.htmlSerialize? [0, "", ""]: [1, "X <div>", "</ div>"]}, sb = db (y),tb = sb.appendChild (y.createElement ("div")); rb.optgroup = rb.option, rb.tbody = rb.tfoot = rb.colgroup = rb.caption = rb.thead, rb.th = rb. td; função ub (a, b) {var c, d, e = 0, f = tipo de a.getElementsByTagName! == K? a.getElementsByTagName (b || "*"): tipo de a.querySelectorAll! == K ? a.querySelectorAll (b || "*"): void 0; if (! f) para (f = [], c = a.childNodes || a; null! = (d = c [e]); e ++ )! b || m.nodeName (d, b)? f.push (d): m.merge (f, ub (d, b)); return void 0 === b || b && m.nodeName (a, b)? m.merge ([a], f): f} função vb (a) {W.test (a.type) && (a.defaultChecked = a.checked)} função wb (a, b) {retorno m.nodeName (a, "table") && m.nodeName (11! == b.nodeType? b: b.firstChild, "tr")? a.getElementsByTagName ("tbody") [0] || a.appendChild ( a.ownerDocument.createElement ("tbody")): a} função xb (a) {return a.type = (nulo! == m.find.attr (a, "tipo")) + "/"+a.type,a}function yb (a) {var b = pb.exec (a.type); retorno b? a.type = b [1]: a.removeAttribute ("type"), a} função zb (a, b) {para (var c, d = 0; nulo! = (c = a [d]); d ++) m._data (c, "globalEval",! b || m._data (b [d], "globalEval"))} function Ab (a, b) {se (1 === b.nodeType && m.hasData (a)) {var c, d, e, f = m._data (a), g = m._data (b, f), h = f.eventos; se (h) {excluir g.handle, g.eventos = {}; para (c in h) para (d = 0, e = h [ c] .length; e> d; d ++) m.event.add (b, c, h [c] [d])} g.data && (g.data = m.extend ({}, g.data)) }} function Bb (a, b) {var c, d, e; if (1 === b.nodeType) {se (c = b.nodeName.toLowerCase (), k.noCloneEvent && b [m.expando]) {e = m._data (b); para (d em e.eventos) m.removeEvent (b, d, e.handle); b.removeAttribute (m.expando)} "script" === c && b.text! == a.text? (xb (b). texto = a.text, yb (b)): "objeto" === c? (b.parentNode && (b.outerHTML = a.outerHTML), k.html5Clone && a.innerHTML &&! m.trim (b.innerHTML) && (b.innerHTML = a.innerHTML)): "entrada" === c && W.test (a.type)? (b.defaultChecked = b.checked = a. checked, b.value! == a.value && (b.value = a.value)): "opção" === c? b.defaultSelected = b.selected = a.defaultSelected :( "entrada" === c || "textarea" === c) && (b.defaultValue = a.defaultValue)}} m.extend ({clone: ​​função (a, b, c) {var d, e, f, g, h, i = m.contains (a.ownerDocument, a); if (k.html5Clone || m.isXMLDoc (a) ||! gb.test ("<" + a.nodeName + ">")? f = a.cloneNode ( ! 0) :( tb.innerHTML = a.outerHTML, tb.removeChild (f = tb.firstChild)),! (K.noCloneEvent && k.noCloneChecked || 1! == a.nodeType && 11! == a.nodeType || m .isXMLDoc (a))) para (d = ub (f), h = ub (a), g = 0; nulo! = (e = h [g]); ++ g) d [g] && Bb (e , d [g]); se (b) se (c) para (h = h || ub (a), d = d || ub (f), g = 0; nulo! = (e = h [g ]); g ++) Ab (e, d [g]);else Ab (a, f); retorno d = ub (f, "script"), d.length> 0 && zb (d,! i && ub (a, "script")), d = h = e = null, f}, buildFragment: function (a, b, c, d) {para (var e, f, g, h, i, j, l, n = comprimento, o = db (b), p = [], q = 0; n> q; q ++) if (f = a [q], f || 0 === f) if ("objeto" === m.type (f)) m.merge (p, f.nodeType ? [f]: f); else if (lb.test (f)) {h = h || o.appendChild (b.createElement ("div")), i = (jb.exec (f) || [ "", ""]] [1] .toLowerCase (), l = rb [i] || rb._default, h.innerHTML = l [1] + f.replace (ib, "<$ 1> </ $ 2> ") + l [2], e = l [0]; enquanto (e -) h = h.lastChild; if (! k.leadingWhitespace && hb.test (f) && p.push (b.createTextNode (hb.exec) f) [0]),! k.tbody) {f = "table"! == i || kb.test (f)? "<table>"! == l [1] || kb.test ( f)? 0: h: h.firstChild, e = f && f.childNodes.length; while (e -) m.nodeName (j = f.childNodes [e], "tbody") &&!j.childNodes.length && f.removeChild (j)} m.merge (p, h.childNodes), h.textContent = ""; while (h.firstChild) h.removeChild (h.firstChild); h = o.lastChild} else p.push (b.createTextNode (f)); h && o.removeChild (h), k.appendChecked || m.grep (ub (p, "entrada"), vb), q = 0; while (f = p [q ++]) if ((! d || -1 === m.inArray (f, d)) && (g = m.contains (f.ownerDocument, f), h = ub (o.appendChild (f) , "script"), g && zb (h), c)) {e = 0; enquanto (f = h [e ++]) ob.test (f.type || "") && c.push (f)} retornar h = null, o}, cleanData: function (a, b) {para (var d, e, f, g, h = 0, i = m.expando, j = m.cache, l = k.deleteExpando, n = m .event.special; null! = (d = a [h]); h ++) se ((b || m.acceptData (d)) && (f = d [i], g = f && j [f])) { if (g.eventos) para (e em g.eventos) n [e]? m.event.remove (d, e): m.removeEvent (d, e, g.handle); j [f] && (delete j [f], l? delete d [i]: digite d.removeAttribute! == K? d.removeAttribute (i): d [i] = nulo, c.push (f))}}}), m.fn.extend ({texto: function (a) {retorno V (isto, função (a) {return void 0 === a? M.text (this): this.empty (). Append ((this [0] && this [0]. ProprietárioDocumento || y) .createTextNode (a))}, nulo, a, argumentos. length)}, append: function () {retornar this.domManip (arguments, function (a) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = wb (isso, a); b.appendChild (a)}})}, prepend: function () {retornar this.domManip (argumentos, função (a) {if (1 === this.nodeType | | 11 === this.nodeType || 9 === this.nodeType) {var b = wb (isso, a); b.insertBefore (a, b.firstChild)}})}, antes de: function () { return this.domManip (argumentos, função (a) {this.parentNode && this.parentNode.insertBefore (a, this)})}, depois de: function () {return this.domManip (argumentos, função (a) {this.parentNode && this. parentNode.insertBefore (a, this.nextSibling)})}, remove: function (a,b) {para (var c, d = a? m.filter (a, isto): isto, e = 0; null! = (c = d [e]); e ++) b || 1! == c. nodeType || m.cleanData (ub (c)), c.parentNode && (b && m.contains (c.ownerDocument, c) && zb (ub (c, "script")), c.parentNode.removeChild (c)); this}, empty: function () {para (var a, b = 0; nulo! = (a = este [b]); b ++) {1 === a.nodeType && m.cleanData (ub (a,! 1) enquanto (a.firstChild) a.removeChild (a.firstChild); a.options && m.nodeName (a, "select") && (a.options.length = 0)} retorna este}, clone: ​​function (a, b) {return a = null == a?! 1: a, b = null == b? a: b, this.map (função () {retorno m.clone (isto, a, b)})}, html: function (a) {retorno V (isto, função (a) {var b = isto [0] || {}, c = 0, d = este.length; if (vazio 0 === a) retorno 1 === b.nodeType? b.innerHTML.replace (fb, ""): void 0; if (! ("string"! = digite um || mb.test (a) ||! k.htmlSerialize && gb.test ( a) ||! k.leadingWhitespace && hb.test (a) || rb [(jb.exec (a) || ["", ""]) [1] .toLowerCase ()])) {a = a.replace (ib, "<$ 1> </ $ 2> "); tente {para (; d> c; c ++) b = este [c] || {}, 1 === b.nodeType && (m.cleanData (ub (b,! 1)), b.innerHTML = a); b = 0} catch (e) {}} b && this.empty (). append (a)}, null, a, argumentos.length)}, replaceWith: function () {var a = argumentos [0]; retorne this.domManip (argumentos, função (b) {a = this.parentNode, m.cleanData (ub (this)), a && a.replaceChild (b, this)}), a && (a.length || a.nodeType)? this: this.remove ()}, desanexar: function (a) {retornar this.remove (a,! 0)}, domManip: function (a, b) {a = e.apply ([] , a), var c, d, f, g, h, i, j = 0, l = este.length, n = isto, o = l-1, p = a [0], q = m.isFunção ( p); if (q || l> 1 && "string" == tipoof p &&! k.checkClone && nb.test (p)) retorne this.each (função (c) {var d = n.eq (c); q && ( a [0] = p.call (isto, c, d.html ())), d.domManip (a, b)}); if (l && (i = m.buildFragment (a, este [0] proprietárioDocumento,! 1, isto), c = i.firstChild, 1 === i.childNodes.length && ( i = c), c)) {para (g = m.map (ub (i, "script"), xb), f = g.length; l> j; j ++) d = i, j! == o && (d = m.clone (d,! 0,! 0), f && m.merge (g, ub (d, "script"))), b.call (isto [j], d, j); se (f ) para (h = g [g.length-1] .ownerDocument, m.map (g, yb), j = 0; f> j; j ++) d = g [j], ob.test (d.type | | "") &&! m._data (d, "globalEval") && m.contains (h, d) && (d.src? m._evalUrl && m._evalUrl (d.src): m.globalEval ((d.text | | d.textContent || d.innerHTML || ""). replace (qb, ""))); i = c = null} retorne este}}), m.each ({appendTo: "append", prependTo: "prepend", insertBefore: "antes", insertAfter: "after", replaceAll: "replaceWith"}, função (a, b) {m.fn [a] = função (a) {para (var c,d = 0, e = [], g = m (a), h = g.length-1; h> = d; d ++) c = d === h? isto: this.clone (! 0), m (g [d]) [b] (c), f.apply (e, c.get ()); retorne this.pushStack (e)}}; var Cb, Db = {}; função Eb (b, c) {var d, e = m (c.createElement (b)). appendTo (corpo.c), f = a.getDefaultComputedStyle && (d = a.getDefaultComputedStyle (e [0]))? d.display: m. css (e [0], "display"); return e.detach (), f} função Fb (a) {var b = y, c = Db [a]; retorno c || (c = Eb (a, b), "nenhum"! == c && c || (Cb = (Cb || m ("<iframe frameborder = '0' largura = '0' altura = '0' />")). appendTo (b.documentElement ), b = (Cb [0] .contentWindow || Cb [0] .contentDocument) .documento, b.write (), b.close (), c = Eb (a, b), Cb.detach ()) , Db [a] = c), c!! Função () {var a; k.shrinkWrapBlocks = função () {if (null! = A) retornar a; a =! 1; var b, c, d; c = y.getElementsByTagName ("corpo") [0], c && c.style? (b = y.createElement ("div"),d = y.createElement ("div"), d.style.cssText = "posição: absoluto; limite: 0; largura: 0; altura: 0; topo: 0; esquerdo: -9999px", c.appendChild (d) .appendChild (b), tipo de b.style.zoom! == K && (b.style.cssText = "- webkit-box-dimensionamento: content-box; -moz-box-size: caixa de conteúdo; box-sizing: content-box; display: bloco; margem: 0; borda: 0; preenchimento: 1px; largura: 1px; zoom: 1 ", b.appendChild (y.createElement (" div ")). style.width =" 5px " , a = 3! == b.offsetWidth), c.removeChild (d), a): void 0}} (); var Gb = / ^ margin /, Hb = new RegExp ("^ (" + S + ") (?! px) [az%] + $ "," i "), Ib, Jb, Kb = / ^ (parte superior | direita | parte inferior | esquerda) $ /; a.getComputedStyle? (Ib = function (a) { return a.ownerDocument.defaultView.getComputedStyle (a, null)}, Jb = função (a, b, c) {var d, e, f, g, h = a.style; retorno c = c || Ib (a ), g = c? c.getPropertyValue (b) || c [b]: void 0, c && (""! == g || m.contains (a.ownerDocument, a) || (g = m.style (a, b)), Hb.test (g) && Gb.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth , h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0 === g? g: g + ""}): y.documentElement.currentStyle && (Ib = função (a) {retornar a.currentStyle}, Jb = função (a, b, c) {var d, e, f, g, h = a.style ; return c = c || Ib (a), g = c? c [b]: void 0, null == g && h && h [b] && (g = h [b]), Hb.test (g) &&! Kb .test (b) && (d = h.left, e = a.runtimeStyle, f = e && e.left, f && (e.left = a.currentStyle.left), h.left = "tamanho da fonte" === b? "1em": g, g = h.pixelLeft + "px", h.left = d, f && (e.left = f)), void 0 === g? G: g + "" || "auto"}) ; função Lb (a, b) {retorno {get: function () {var c = a (); if (null! = c) retorna c? void delete this.get: (this.get = b) .apply ( isto, argumentos)}}}! function () {var b,c, d, e, f, g, h; if (b = y.createElement ("div"), b.innerHTML = "<link /> <tabela> </ table> <a href='/a'> a </a> <input type = 'checkbox' /> ", d = b.getElementsByTagName (" a ") [0], c = d && d.style) {c.cssText =" flutuante: esquerdo; opacidade: .5 ", k.opacity =" 0.5 "=== c.opacity, k.cssFloat = !! c.cssFloat, b.style.backgroundClip =" caixa de conteúdo ", b.cloneNode (! 0) .style.backgroundClip = "", k.clearCloneStyle = "caixa de conteúdo" === b.style.backgroundClip, k.boxSizing = "" === c.boxSizing || "" === c.MozBoxSizing || "" === c.WebkitBoxSizing, m.extend (k, {trustedHiddenOffsets: function () {retorno null == g && i (), g}, boxSizingReliable: function () {retorno null == f && i (), f}, pixelPosition: function () {return null == e && i (), e}, trustedMarginRight:function () {return null == h && i (), h}}; função i () {var b, c, d, i; c = y.getElementsByTagName ("corpo") [0], c && c.style && (b = y.createElement ("div"), d = y.createElement ("div"), d.style.cssText = "posição: absoluto; limite: 0; largura: 0; altura: 0; topo: 0; esquerdo: -9999px ", c.appendChild (d) .appendChild (b), b.style.cssText =" - dimensionamento do webkit-box: caixa de bordas; -moz-box-sizing: caixa de borda; dimensionamento de caixa: borda -box; display: bloco; margem-topo: 1%; topo: 1%; borda: 1px; preenchimento: 1px; largura: 4px; posição: absoluto ", e = f =! 1, h =! 0, a. getComputedStyle && (e = "1%"! == (a.getComputedStyle (b, nulo) || {}). top, f = "4px" === (a.getComputedStyle (b, nulo) || {largura: "4px"}) .width, i = b.appendChild (y.createElement ("div")), i.style.cssText = b.style.cssText = "- dimensionamento do webkit-box: content-box; -moz -box-sizing: content-box;box-sizing: content-box; display: bloco; margem: 0; borda: 0; preenchimento: 0 ", i.style.marginRight = i.style.width =" 0 ", b.style.width =" 1px " , h =! parseFloat ((a.getComputedStyle (i, nulo) || {}). marginRight)), b.innerHTML = "<tabela> <tr> <td> </ td> <td> t </ td > </ tr> </ table> ", i = b.getElementsByTagName (" td "), i [0] .style.cssText =" margem: 0; borda: 0; preenchimento: 0; exibição: nenhum ", g = 0 === i [0] .offsetHeight, g && (i [0] .style.display = "", i [1] .style.display = "nenhum", g = 0 === i [0]. offsetHeight), c.removeChild (d))}}} (), m.swap = função (a, b, c, d) {var e, f, g = {}; para (f em b) g [f ] = a.style [f], a.style [f] = b [f]; e = c.apply (a, d || []), para (f in b) a.style [f] = g [f]; return e}; var Mb = / alpha \ ([^)] * \) / i, Nb = / opacidade \ s * = \ s * ([^)] *) /, Ob = / ^ ( nenhum | tabela (?! - c [ea]). +) /, Pb = new RegExp ("^ (" + S + ") (. *) $", "i"), Qb = new RegExp ("^ ([+ -]) = (" + S + ")", "i"), Rb = {posição: "absoluto", visibilidade: "oculto", exibição: "bloco"}, Sb = {letterSpacing: "0", fontWeight: "400"}, Tb = ["Webkit", "O", "Moz", "ms"]; função Ub (a, b) {se (b em a) return b; var c = b.charAt (0) .toUpperCase () + b.slice (1), d = b, e = Tb.length; while (e -) if (b = Tb [e] + c, b em a) retorno b; retorno d} função Vb (a, b) {para (var c, d, e, f = [], g = 0, h = a.length; h> g; g ++) d = a [g], d.style && (f [g] = m._data (d, "olddisplay"), c = d.style.display, b? (f [g] || "nenhum "! == c || (d.style.display =" ")," "=== d.style.display && U (d) && (f [g] = m._data (d," olddisplay ", Fb ( d.nodeName)))) :( e = U (d), (c && "nenhum"! == c ||! e) && m._data (d, "olddisplay", e? c: m.css (d, "display")))); para (g = 0; h> g; g ++) d = a [g], d.style && (b && "nenhum"! == d.style.display && ""! == d.style.display || (d.style.display = b? f [g] || "": "nenhum")); retornar a} função Wb (a, b, c) {var d = Pb .exec (b); retorno d? Math.max (0, d [1] - (c || 0)) + (d [2] || "px"): b} função Xb (a, b, c , d, e) {para (var f = c === (d? "borda": "conteúdo")? 4: "largura" === b? 1: 0, g = 0; 4> f; f + = 2) "margin" === c && (g + = m.css (a, c + T [f], 0, e)), d? ("Conteúdo" === c && (g- = m.css (a, "preenchimento" + T [f], 0, e)), "margem"! == c && (g- = m.css (a, "borda" + T [f] + "Largura",! 0, e))): (g + = m.css (a, "preenchimento" + T [f], 0, e), "preenchimento"! == c && (g + = m.css (a, "borda" + T [f] + "Largura",! 0, e))); retorno g} função Yb (a, b, c) {var d =! 0, e = "width "=== b? a.offsetWidth: a.offsetHeight, f = lb (a), g = k.boxSizing &&" border-box "=== m.css (a," boxSizing ",! 1, f) ; if (0> = e || null == e) {se (e = Jb (a, b, f), (0> e || null == e) && (e = a.style [b]) , Hb.test (e)) return e; d = g && (k.boxSizingReliable () || e === a.style [b]), e = parseFloat (e) || 0} return e + Xb (a , b, c || (g? "fronteira": "conteúdo"), d, f) + "px"} m.extend ({cssHooks: {opacidade: {get: function (a, b) {if (b ) {var c = Jb (a, "opacidade"); return "" === c? "1": c}}}}, cssNumber: {columnCount:! 0, fillOpacity:! 0, flexGrow:! 0, flexShrink:! 0, fontWeight:! 0, lineHeight:! 0, opacidade:! 0, ordem:! 0, órfãos:! 0, viúvas:! 0, zIndex:! 0, zoom:! 0}, cssProps: {" float ": k.cssFloat?" cssFloat ":" styleFloat "}, estilo: function (a, b, c, d) {se (a && 3! == a.nodeType && 8! == a.nodeType && a.style) {var fg, h = m.camelCase (b), i = a.style; if (b = m.cssProps [h] || (m.cssProps [h] = Ub (i, h)), g = m.cssHooks [b] || m.cssHooks [h], void 0 === c) return g && "get" em g && void 0! == (e = g.get (a,! 1, d))? e: i [ b]; if (f = typeof c, "string" === f && (e = Qb.exec (c)) && (c = (e [1] +1) * e [2] + parseFloat (m.css (a, b)), f = "número"), nulo! = c && c === c && ("número"! == f || m.cssNúmero [h] || (c + = "px"), k. clearCloneStyle || ""! == c || 0! == b.indexOf ("background") || (i [b] = "herdar"),! (g && "set" em g && void 0 === (c = g.set (a, c, d))))) try {i [b] = c} captura (j) {}}}, css: function (a, b, c, d) {var e f , g, h = m.camelCase (b); retorno b = m.cssProps [h] || (m.cssProps [h] = Ub (a.style, h)), g = m.cssHooks [b] | | m.cssHooks [h], g && "get" em g && (f = g.get (a,! 0, c)), void 0 === f && (f = Jb (a, b, d)), "normal "=== f && b em Sb && (f = Sb [b])," "=== c || c? (e = parseFloat (f), c ===! 0 || m.isNumeric (e)? e || 0: f): f}}), m.each (["altura", "largura"], função (a, b) {m.cssHooks [b] = {get: function (a, c, d) {return c? Ob.test (m.css (a, "display")) && 0 === a.offsetWidth? m.swap (a, Rb, função () {return Yb (a, b, d) }): Yb (a, b, d): void 0}, conjunto: function (a, c, d) {var e = d & a Ib (a); retorno Wb (a, c, d? Xb (a, b, d, k.boxSizing && "border-box" === m.css (a, "boxSizing",! 1, e), e): 0)}}}), k.opacity || (m.cssHooks.opacity = {get: function (a, b) {retornar Nb.test ((b && a.currentStyle? a.currentStyle.filter: a.style.filter) || "") ?. 01 * parseFloat (RegExp. $ 1) + " ": b?" 1 ":" "}, set: function (a, b) {var = a.style, d = a.currentStyle, e = m.isNumeric (b)?" alpha (opacidade = "+ 100 * b + ")": "",f = d && d.filter || c.filter || ""; c.zoom = 1, (b> = 1 || "" === b) && "" === m.trim (f.replace (Mb) , "")) && c.removeAttribute && (c.removeAttribute ("filtro"), "" === b || d &&! d.filter) || (c.filter = Mb.test (f)? f.replace ( Mb, e): f + "" + e)}}), m.cssHooks.marginRight = Lb (k.reliableMarginRight, function (a, b) {retornar b? M.swap (a, {display: "inline-block "}, Jb, [a," marginRight "]): void 0}), m.each ({margin:" ", padding:" ", border:" Width "}, função (a, b) {m. cssHooks [a + b] = {expandir: function (c) {para (var d = 0, e = {}, f = "string" == typeof c? c.split (""): [c]; > d; d ++) e [a + T [d] + b] = f [d] || f [d-2] || f [0]; retorne e}}, Gb.test (a) || ( m.cssHooks [a + b] .set = Wb)}), m.fn.extend ({css: função (a, b) {retorno V (isto, função (a, b, c) {var d, e , f = {}, g = 0; se (m.isArray (b)) {para (d = Ib (a), e = b.length; e> g; g ++) f [b [g]] = m.css (a, b [g], 1, d ); return f} return void 0! == c? m.style (a, b, c): m.css (a, b)}, a, b, argumentos.length> 1)}, show: function ( ) {return Vb (isso,! 0)}, hide: function () {retorna Vb (this)}, toggle: function (a) {return "booleano" == typeof a? a? this.show (): .hide (): this.each (function () {U (this)? m (this) .show (): m (this) .hide ()})}}); função Zb (a, b, c, d, e) {retornar novo Zb.prototype.init (a, b, c, d, e)} m.Tween = Zb, Zb.prototype = {construtor: Zb, init: function (a, b, c, d , e, f) {this.elem = a, this.prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur (), este .end = d, this.unit = f || (m.cssNumber [c]? "": "px")function () {retornar Vb (this)}, alternar: function (a) {return "booleano" == tipoof a? a? this.show (): this.hide (): this.each (function () {U (this)? m (this) .show (): m (this) .hide ()})}}); função Zb (a, b, c, d, e) {retornar novo Zb.prototype.init (a , b, c, d, e)} m.Tween = Zb, Zb.prototype = {construtor: Zb, init: function (a, b, c, d, e, f) {this.elem = a, isto. prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur (), this.end = d, this.unit = f || (m .cssNumber [c]? "": "px")function () {retornar Vb (this)}, alternar: function (a) {return "booleano" == tipoof a? a? this.show (): this.hide (): this.each (function () {U (this)? m (this) .show (): m (this) .hide ()})}}); função Zb (a, b, c, d, e) {retornar novo Zb.prototype.init (a , b, c, d, e)} m.Tween = Zb, Zb.prototype = {construtor: Zb, init: function (a, b, c, d, e, f) {this.elem = a, isto. prop = c, this.easing = e || "swing", this.options = b, this.start = this.now = this.cur (), this.end = d, this.unit = f || (m .cssNumber [c]? "": "px")now = this.cur (), this.end = d, this.unit = f || (m.cssNumber [c]? "": "px")now = this.cur (), this.end = d, this.unit = f || (m.cssNumber [c]? "": "px")
}, cur: function () {var a = Zb.propHooks [this.prop]; retorna a && a.get? a.get (this): Zb.propHooks._default.get (this)}, execute: function (a) {var b, c = Zb.propHooks [this.prop]; retorne this.pos = b = this.options.duration?m.easing [this.easing] (a, this.options.duration * a, 0,1 , this.options.duration): a, this.now = (this.end-this.start) * b + this.start, this.options.step && this.options.step.call (this.elem, this.now, this), c & c.set? c.set (this): Zb.propHooks._default.set (this), este}}, Zb.prototype.init.prototype = Zb.prototype, Zb.propHooks = {_ default: {get : function (a) {var b; return nulo == a.elem [a.prop] || a.elem.style && null! = a.elem.style [a.prop]? (b = m.css (a. elem, a.prop, ""), b && "auto"! == b? b: 0): a.elem [a.prop]}, conjunto: function (a) {m.fx.step [a.prop ]? m.fx.step [a.prop] (a): a.elem.style && (null! = a.elem.style [m.cssProps [a.prop]] || m.cssHooks [a.prop])? m.style (a.elem, a.prop, a.now + a.unit): a.elem [a.prop] = a.now}}}, Zb.propHooks.scrollTop = Zb.propHooks .scrollLeft = {set: function (a) {a.elem.nodeType && a.elem.parentNode && (a.elem [a.prop] = a.now)}}, m.easing = {linear: função (a) {retorno a}, swing: function (a) {return.5-Math.cos (a * Math.PI) / 2}}, m.fx = Zb.prototype.init, m.fx.step = {}; var $ b, _b, ac = / ^ (?: alternar | mostrar | ocultar) $ /, bc = new RegExp ("^ (?: ([+ -]) = |) (" + S + ") ([az%] *) $ "," i "), cc = / queueHooks $ /, dc = [ic], ec = {" * ": [função (a, b) {var c = this.createTween (a, b), d = c.cur (), e = bc.exec (b), f = e & e [cos (a * Math.PI) / 2}}, m.fx = Zb.prototype.init, m.fx.step = {}; var $ b, _b, ac = / ^ (?: alternar | mostrar | ocultar ) $ /, bc = new RegExp ("^ (?: ([+ -]) = |) (" + S + ") ([az%] *) $", "i"), cc = / queueHooks $ / , dc = [ic], ec = {"*": [função (a, b) {var = c.cctteTween (a, b), d = c.cur (), e = bc.exec (b) , f = e & e [cos (a * Math.PI) / 2}}, m.fx = Zb.prototype.init, m.fx.step = {}; var $ b, _b, ac = / ^ (?: alternar | mostrar | ocultar ) $ /, bc = new RegExp ("^ (?: ([+ -]) = |) (" + S + ") ([az%] *) $", "i"), cc = / queueHooks $ / , dc = [ic], ec = {"*": [função (a, b) {var = c.cctteTween (a, b), d = c.cur (), e = bc.exec (b) , f = e & e [3] || (m.cssNumber [a]? "": "Px"), g = (m.cssNumber [a] || "px"! == f && + d) && bc.exec (m.css (c .elem, a)), h = 1, i = 20; se (g && g [3]! == f) {f = f || g [3], e = e || [], g = + d | | 1; h = h || ".5", g / = h, m.style (c.elem, a, g + f); enquanto (h! == (h = c.cur () / d ) && 1! == h && - i)} return e && (g = c.start = + g || + d || 0, c.unidade = f, c.end = e [1]? G + (e [1 ] +1) * e [2]: + e [2]), c}]}; função fc () {retorno setTimeout (function () {$ b = void 0}), $ b = m.now () } função gc (a, b) {var c, d = {altura: a}, e = 0; para (b = b? 1: 0; 4> e; e + = 2-b) c = T [e] , d ["margin" + c] = d ["preenchimento" + c] = a; retorno b && (d.opacity = d.width = a), d} função hc (a, b, c) {para (var d, e = (ec [b] || []). concat (ec ["*"]), f = 0, g = e.length; g> f; f ++) if (d = e [f]. chamar (c, b, a)) retornar d} função ic (a, b, c) {var d, e, f, g, h, i, j, l, n = isso, o = {}, p = a.style, q = a.nodeType && U (a), r = m._data (a, "fxshow"c.queue || (h = m._queueHooks (a, "fx"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function ( ) {h.unqueued || i ()}), h.unqueued ++, n.always (função () {n.always (function () {h.unqueued -, m.queue (a, "fx"). length || h.empty.fire ()})})), 1 === a.nodeType && ("height" em b || "width" em b) && (c.overflow = [p.overflow, p. overflowX, p.overflowY], j = m.css (a, "display"), l = "nenhum" === j? m._data (a, "olddisplay") || Fb (a.nodeName): j , "inline" === l && "none" === m.css (a, "float") && (k.inlineBlockNeedsLayout && "inline"! == Fb (a.nodeName)? p.zoom = 1: p. display = "inline-block")), c.overflow && (p.overflow = "oculto", k.shrinkWrapBlocks () || n.always (function () {p.overflow = c.overflow [0], p. overflowX = c.overflow [1], p.overflowY = c.overflow [2]})); para (d em b) if (e = b [d], ac.exec (e)) {se (excluir b [d], f = f || "alternar "=== e, e === (q?" esconder ":" mostrar ")) {if (" mostrar "! == e ||! r || void 0 === r [d]) continuar; q =! 0} o [d] = r && r [d] || m.style (a, d)} mais j = void 0; if (m.isEmptyObject (o)) "inline" === ("nenhum" === j? Fb (a.nodeName): j) && (p.display = j); else {r? "oculto" em r && (q = r.hidden): r = m._data (a, "fxshow ", {}), f && (r.hidden =! q), q? m (a) .show (): n.done (função () {m (a) .hide ()}), n.done ( function () {var b; m._removeData (a, "fxshow"); para (b em o) m.style (a, b, o [b])}); para (d em o) g = hc ( q? r [d]: 0, d, n), d em r || (r [d] = g.start, q && (g.end = g.start, g.start = "largura" === d || "height" === d? 1: 0))}} jc (a, b) {var c, d, e, f, g; para (c em a) if (d = m.camelCase ( c), e = b [d], f = a [c], m.isArray (f) && (e = f [1],f = a [c] = f [0]), c! == d && (a [d] = f, apaga a [c]), g = m.cssHooks [d], g && "expandir" em g) { f = g.expand (f), delete a [d], para (c in f) c em a || (a [c] = f [c], b [c] = e)} mais b [d] = e} função kc (a, b, c) {var d, e, f = 0, g = dc.length, h = m.Deferred (). sempre (function () {excluir i.elem}), i = function () {if (e) return! 1; para (var b = $ b || fc (), c = Math.max (0, j.startTime + j.duração-b), d = c / j .duration || 0, f = 1-d, g = 0, i = j.tweens.length; i> g; g ++) j.tweens [g] .run (f); retorno h.notificarCom (a, [ j, f, c]), 1> f && i? c: (h.resolveWith (a, [j]) ,! 1)}, j = h.promise ({elem: a, props: m.extend ({}} b) opts: m.extend (! 0, {specialEasing: {}}, c), originalPropriedades: b, originalOptions: c, startTime: $ b || fc (), duração: c.duration, tweens: [ ], createTween: function (b, c) {var d = m.Tween (a, j.opts, b, c, j.opts.specialEasing [b] || j.opts.easing); retorno j.tweens. empurrar (d), d}, parar: função (b) {var c = 0, d = bjensens.length: 0; se (e) retornar isto;para (e =! 0; d> c; c ++) j.tweens [c] .run (1); retornar b? h.resolveWith (a, [j, b]): h.rejectWith (a, [j, b]), this}}), k = j.props; para (jc (k, j.opts.specialEasing); g> f; f ++) if (d = dc [f] .call (j, a, k , retorne m.map (k, hc, j), m.isFunction (j.opts.start) && j.opts.start.call (a, j), m.fx.timer ( m.extend (i, {elem: a, anim: j, fila: j.opts.queue})), j.progress (j.opts.progress) .done (j.opts.done, j.opts.complete ) .fail (j.opts.fail) .sempre (j.opts.always)} m.Animation = m.extend (kc, {tweener: função (a, b) {m.isFunção (a)? (b = a, a = ["*"]): a = a.split (""); para (var c, d = 0, e = a.length; e> d; d ++) c = a [d], ec [c] = ec [c] || [], ec [c] .shift (b)}, prefilter: function (a, b) {b? dc.unshift (a): dc.push (a)}} ), m.speed = função (a, b, c) {var d = a && "objeto" == tipoof a? m.extend ({}, a): {complete: c ||! c && b || m.isFunction (a) && a, duração: a, facilitando: c && b || b &&!m.isFunction (b) && b}; return d.duration = m.fx.off 0: "number" == typeof d.duration? d.duration: d.duration em m.fx.speeds? m.fx. velocidades [d.duration]: m.fx.speeds._default, (null == d.queue || d.queue ===! 0) && (d.queue = "fx"), d.old = d. complete, d.complete = function () {m.isFunction (d.old) && d.old.call (este), d.queue && m.dequeue (this, d.queue)}, d}, m.fn.extend ( {fadeTo: function (a, b, c, d) {retornar this.filter (U) .css ("opacidade", 0) .show (). end (). animar ({opacidade: b}, a, c , d)}, animado: função (a, b, c, d) {var e = m.isEmptyObject (a), f = m.speed (b, c, d), g = função () {var b = kc (this, m.extend ({}, a), f); (e || m._data (this, "finish")) && b.stop (! 0)}; return g.finish = g, e | | f.queue ===! 1? this.each (g): this.queue (f.queue, g)}, stop: função (a, b, c) {var d = função (a) {var = a.stop; delete a.stop, b (c)}; retorna "string"! = typeof a &&(c = b, b = a, a = void 0), b && a! ==! 1 && this.queue (a || "fx", []), this.each (função () {var b =! 0, e = null! = a && a + "queueHooks", f = m.timers, g = m._data (this); se (e) g [e] && g [e] .stop && d (g [e]); else para (e in g) g [e] && g [e] .stop && cc.test (e) && d (g [e]); para (e = f.length; e -;) f [e] .elem! == isto || null! = a && f [e] .queue! == a || (f [e] .anim.stop (c), b =! 1, f.splice (e, 1)); (b ||! c) && m.dequeue (this, a)})}, finish: function (a) {return a! ==! 1 && (a = a || "fx"), this.each (função () {var b, c = m._data (isto), d = c [a + "fila"], e = c [a + "filaHooks"], f = m.timers, g = d? d.length: 0; para (c.finish =! 0, m.queue (isto, a, []), e && e.stop && e.stop.call (isto,! 0), b = f.length; b -;) f [b] .elem === isto && f [ b) .queue === a && (f [b] .anim.stop (! 0), f.splice (b, 1)); para (b = 0; g> b; b ++) d [b] &&d [b] .finish && d [b] .finish.call (isto); delete c.finish})}}), m.each (["toggle", "show", "hide"], função (a, b ) {var c = m.fn [b]; m.fn [b] = função (a, d, e) {retorno nulo == a || "booleano" == tipo de a? c.apply (isto, argumentos ): this.animate (gc (b,! 0), a, d, e)}}), m.each ({slideDown: gc ("mostrar"), slideUp: gc ("ocultar"), slideToggle: gc ("toggle"), fadeIn: {opacidade: "show"}, fadeOut: {opacidade: "ocultar"}, fadeToggle: {opacidade: "toggle"}}, function (a, b) {m.fn [a] = function (a, c, d) {retornar this.animate (b, a, c, d)}}), m.timers = [], m.fx.tick = function () {var a, b = m .timers, c = 0; para ($ b = m.now (); c <b.length; c ++) a = b [c], a () || b [c]! == a || b. splice (c -, 1); b.length || m.fx.stop (), $ b = void 0}, m.fx.timer = função (a) {m.timers.push (a), um ()? m.fx.start (): m.timers.pop ()}, m.fx.interval = 13, m.fx.start = função () {_ b || (_b = setInterval (m.fx.tick, m.fx.interval))}, m.fx.stop = função () {clearInterval (_b), _ b = nulo}, m.fx.speeds = {lento: 600, rápido: 200, _default: 400} , m.fn.delay = function (a, b) {return a = m.fx? m.fx.speeds [a] || a: a, b = b || "fx", this.queue (b, função (b, c) {var d = setTimeout (b, a); c.stop = função () {clearTimeout (d)}})}, função () {var a, b, c, d, e; = y.createElement ("div"), b.setAttribute ("className", "t"), b.innerHTML = "<link /> <tabela> </ table> <a href='/a'> a < / a> <input type = 'checkbox' /> ", d = b.getElementsByTagName (" a ") [0], c = y.createElement (" selecionar "), e = c.appendChild (y.createElement (" opção ")), a = b.getElementsByTagName (" input ") [0], d.style.cssText =" início: 1px ", k.getSetAttribute =" t "! == b.className, k.style = / top / .test (d.getAttribute ("style")), k.hrefNormalized = "/ a" === d.getAttribute ("href"), k.checkOn = !! a.value, k.optSelected = e.selected, k.enctype = !! y.createElement ("form") .enctype, c.disabled =! 0, k.optDisabled =! e.disabled, a = y.createElement ("entrada"), a.setAttribute ("valor", ""), k.input = "" == = a.getAttribute ("valor"), a.value = "t", a.setAttribute ("tipo", "rádio"), k.radioValue = "t" === a.value} (); var lc = / \ r / g; m.fn.extend ({val: function (a) {var b, c, d, e = isto [0]; {if (arguments.length) retorna d = m.isFunction (a ), this.each (function (c) {var e; 1 === this.nodeType && (e = d? a.call (isto, c, m (isto) .val ()): a, null == e ? e = "": "numero" == tipoof e? e + = "": m.isArray (e) && (e = m.map (e, funcao (a) {retorno nulo == a? "": a + ""})), b = m.valHooks [this.type] || m.valHooks [isto.nodeName.toLowerCase ()], b && "set" em b && void 0! == b.set (this, e, "valor") || (this.value = e))}); se (e) retornar b = m .valHooks [e.type] || m.valHooks [e.nodeName.toLowerCase ()], b && "get" em b && void 0! == (c = b.get (e, "valor"))? c :( c = e.value, "string" == tipo de c? c.replace (lc, ""): null == c? "": c)}}}), m.extend ({valHooks: {option: { get: function (a) {var b = m.find.attr (a, "valor"); retorno nulo! = b? b: m.trim (m.text (a))}}, selecione: {get: function (a) {para (var b, c, d = a.options, e = a.selectedIndex, f = "select-one" === a.type || 0> e, g = f? null: [ ], h = f e e + 1: d.length, i = 0> eh: f e e: 0; h> i; i ++) se (c = d [i],! (! c.selected && i! == e || (k.optDisabled? c.disabled: null! == c.getAttribute ("desativado")) || c.parentNode.disabled && m.nodeName (c.parentNode, "optgroup"))) {if ( b = m (c).val (), f) return b; g.push (b)} return g}, set: function (a, b) {var c, d, e = a.options, f = m.makeArray (b), g = e.length; while (g -) se (d = e [g], m.inArray (m.valHooks.option.get (d), f)> = 0) try {d.selected = c =! 0} pegar (h) {d.scrollHeight} else d.selected =! 1; retornar c || (a.selectedIndex = -1), e}}}}), m.each (["radio", "checkbox "], function () {m.valHooks [this] = {conjunto: function (a, b) {retorno m.isArray (b)? a.checked = m.inArray (m (a) .val (), b )> = 0: void 0}}, k.checkOn || (m.valHooks [isto] .get = function (a) {retorno nulo === a.getAttribute ("valor")? "Em": a. valor})}); var mc, nc, oc = m.expr.attrHandle, pc = / ^ (?: verificado | selecionado) $ / i, qc = k.getSetAttribute, rc = k.input; m.fn. extend ({attr: function (a, b) {retornar V (isto, m.attr, a, b, argumentos.length> 1)}, removeAttr: function (a) {retornar this.each (function () {m .removeAttr (this, a)})}}), m.extend ({attr: function (a, b, c) {var d, e, f = a.nodeType;if (a && 3! == f && 8! == f && 2! == f) retornar typeof a.getAttribute === K? m.prop (a, b, c): (1 === f && m.isXMLDoc (a) || (b = b.toLowerCase (), d = m.attrHooks [b] || (m.expr.match.bool.test (b)? nc: mc)), nulo 0 === c? d && "get" em d && null! == (e = d.get (a, b)) e: (e = m.find.attr (a, b), null == e? void 0: e): null! == c ? d && "set" em d && void 0! == (e = d.set (a, c, b))? e: (a.setAttribute (b, c + ""), c): void m.removeAttr (a, b))}, removeAttr: function (a, b) {var c, d, e = 0, f = b && b.match (E); if (f && 1 === a.nodeType) while (c = f [e ++] ) d = m.propFix [c] || c, m.expr.match.bool.test (c)? rc & qc ||! pc.test (c)? a [d] =! 1: a [m.camelCase ("default -" + c)] = a [d] =! 1: m.attr (a, c, ""), a.removeAttribute (qc? c: d)}, attrHooks: {type: {conjunto: function (a, b) {se (! k.radioValue && "radio" === b && m.nodeName (a, "entrada")) {var c = a.value; retorno a.setAttribute ("type", b), c && (a.value = c), b}}}}}), nc = {set: function (a, b, c) {return b ===! 1? m.removeAttr (a, c): rc && qc ||! pc.test (c)? a.setAttribute (! qc && m.propFix [c] || c, c): a [m.camelCase ("default -" + c)] = a [c] =! 0, c}}, m.each (m.expr.match.bool.source.match (/ \ w + / g), function (a, b) {var c = oc [b] || m.find.attr; oc [b] = rc & qc ||! pc.test (b)? função (a, b, d) {var e f ; return d || (f = oc [b], oc [b] = e, e = null! = c (a, b, d)? b.toLowerCase (): null, oc [b] = f), e}: function (a, b, c) {retornar c? void 0: a [m.camelCase ("default -" + b)]? b.toLowerCase (): null}}), rc && qc || (m. attrHooks.value = {set: function (a, b, c) {return m.nodeName (a, "input")? void (a.defaultValue = b): mc & mc.set (a, b, c)}}) , qc || (mc = {set: function (a, b, c) {var d = a.getAttributeNode (c); retorno d || a.setAttributeNode (d = a.ownerDocument.createAttribute (c)), d .valor = b + = "", "valor" === c || b === a.getAttribute (c)? b: void 0}}, oc.id = oc.name = oc.coord = função (a, b, c) {var d; retorno c? void 0: (d = a.getAttributeNode (b)) && ""! == d.value? d.value: null}, m.valHooks.button = {get: function (a, b) {var c = a.getAttributeNode (b); return c && c.specified? c.value: void 0}, conjunto: mc.set}, m.attrHooks.contenteditable = {conjunto: function (a, b, c) {mc.set (a, "" === b?! 1: b, c)}}, m.each (["largura", "altura"], função (a, b) {m .attrHooks [b] = {set: function (a, c) {retorno "" === c? (a.setAttribute (b, "auto"), c): void 0}}})), k.style || (m.attrHooks.style = {get: function (a) {retornar a.style.cssText || void 0}, set: function (a, b) {retornar a.style.cssText = b + ""}} ); var sc = / ^ (?: input | select | área de texto | botão | objeto) $ / i, tc = / ^ (?: a | área) $ / i; m.fn.extend ({prop: function ( a, b) {retorno V (isto, m.prop, a, b,arguments.length> 1)}, removeProp: function (a) {return a = m.propFix [a] || a, this.each (function () {try {isto [a] = void 0, delete isto [a }} catch (b) {}})}}), m.extend ({propFix: {"para": "htmlFor", "class": "className"}, prop: function (a, b, c) { var d, e, f, g = a.nodeType; se (a && 3! == g && 8! == g && 2! == g) retorne f = 1! == g ||! m.isXMLDoc (a), f && (b = m.propFix [b] || b, e = m.propHooks [b]), void 0! == c? e && "set" em e && void 0! == (d = e.set (a, c, b ))? d: a [b] = c: e && "get" em e && null! == (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: function (a) {var b = m.find.attr (a, "tabindex"); retorno b? parseInt (b, 10): sc.test (a.nodeName) || tc.test (a.nodeName) && a .href? 0: -1}}}}), k.hrefNormalizado || m.each (["href", "src"], função (a, b) {m.propHooks [b] = {get: function (a) {return a.getAttribute (b, 4)}}}), k.optSelected || (m.propHooks.selected = {get: function (a) {var b = a.parentNode; retorno b && (b.selectedIndex, b.parentNode && b.parentNode .selectedIndex), null}}), m.each ([tabIndex, readOnly, maxLength, cellSpacing, cellPadding, rowSpan, colSpan, useMap, frameBorder, "contentEditable"], function () {m.propFix [this.toLowerCase ()] = este}), k.enctype || (m.propFix.enctype = "codificação"); var uc = / [\ t \ r \ n \ f] /g;m.fn.extend ({addClass: function (a) {var b, c, d, e, f, g, h = 0, i = este.length, j = "string" == typeof a && a; if (m.isFunction (a)) return this.each (function (b) {m (this) .addClass (a.call (isto, b, this.className))}); if (j ) para (b = (a || ""). match (E) || []; i> h; h ++) if (c = este [h], d = 1 === c.nodeType && (c.className? ("" + c.className + "") .replace (uc, ""): "")) {f = 0; enquanto (e = b [f ++]) d.indexOf ("" + e + "") <0 && (d + = e + ""); g = m.trim (d), c.className! == g && (c.className = g)} retorna isto}, removeClass: function (a) {var b, c, d, e, f, g, h = 0, i = este.length, j = 0 === argumentos.length || "string" == tipo de a && a; if (m.isFunction (a)) return this.each (função (b) {m (this) .removeClass (a.call (isto, b, this.className))}); if (j) para (b = (a || ""). correspondência (E) | | []; i> h; h ++) if (c = este [h], d = 1 === c.nodeType && (c.className? ("" + c.className + "") .replace (uc, "" ): "")) {f = 0; while (e = b [f ++]) enquanto (d.indexOf ("" + e + "")> = 0) d = d.replace ("" + e + "", ""); g = a? m.trim (d): "", c.className! == g && (c.className = g)} retornar isto}, toggleClass: function (a, b) {var c = tipo de um; retorno "booleano" == typeof b && "string" === c? b? this.addClass (a): this .removeClass (a): this.each (m.isFunction (a)? função (c) {m (this) .toggleClass (a.call (isto, c, this.className, b), b)}: function ( ) {if ("string" === c) {var b, d = 0, e = m (isto), f = a.match (E) || []; while (b = f [d ++]) e .hasClass (b)? e.removeClass (b): e.addClass (b)} mais (c === K || "booleano" === c) && (this.className && m._data (isto, "__ className__" , this.className), this.className = this.className || a ===! 1? "": m._data (isso, "__ className __") || "")})}, hasClass: function (a) {para (var b = "" + a + "", c = 0, d = este.length; d> c; c ++) if (1 === este [c] .nodeType && ("" + isto [c]. className + "") .replace (uc, "") .indexOf (b)> = 0) retornar!0; return! 1}}), m.each ("desfocagem foco focusin focusout carga redimensionar rolagem descarregar clique dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mudança de mouse mudança selecionar enviar keydown keypress erro de formatação contextmenu" .split (""), function (a , b) {m.fn [b] = função (a, c) {retorno arguments.length> 0? this.on (b, nulo, a, c): this.trigger (b)}}), m. fn.extend ({hover: function (a, b) {retorne this.mouseenter (a) .mouseleave (b || a)}, bind: function (a, b, c) {retorne this.on (a, nulo , b, c)}, unbind: function (a, b) {retornar this.off (a, null, b)}, delegado: function (a, b, c, d) {retornar this.on (b, a , c, d)}, undelegate: function (a, b, c) {retorno 1 === argumentos.length? this.off (a, "**"): this.off (b, a || "* * ", c)}}); var vc = m.now (), wc = / \? /, xc = / (,) | (\ [| {) | (} |]) |" (?: [ ^ "\\\ r \ n] | \\ [" \\\ / bfnrt] | \\ u [\ da-fA-F] {4}) * "\ s * :? | verdadeiro | falso | nulo | -? (?! 0 \ d) \ d + (?: \.\ d + |) (?: [eE] [+ -]? \ d + |) /g;m.parseJSON=function (b) {se (a.JSON && a.JSON.parse) devolve a.JSON.parse (b + " "); var c, d = nulo, e = m.trim (b +" "); retorno e &&! m.trim (e.replace (xc, função (a, b, e, f) {retorno c && b && (d = 0), 0 === d? A: (c = e || b, d + =! F-! E, "")}))? Função ("retorno" + e) ​​(): m.error (" JSON inválido: "+ b)}, m.parseXML = função (b) {var c, d; if (! B ||" string "! = Typeof b) retorno nulo; tente {a.DOMParser? (D = novo DOMParser, c = d.parseFromString (b, "text / xml")): (c = new ActiveXObject ("Microsoft.XMLDOM"), c.async = "falso", c.loadXML (b))} catch (e ) {c = void 0} return c && c.documentElement &&! c.getElementsByTagName ("parsererror"). length || m.error ("XML Inválido:" + b), c}; var yc, zc, Ac = / #. * $ /, Bc = / ([? &]) _ = [^ &] * /, Cc = / ^ (. *?): [\ T] * ([^ \ r \ n] *) \ r? $ / gm, Dc = / ^ (?:sobre | app | app-storage |. + - extensão | arquivo | res | widget): $ /, Ec = / ^ (?: GET | HEAD) $ /, Fc = / ^ \ / \ //, Gc = / ^ ([\ w. + -] +:) (?: \ / \ / (?: [^ \ /? #] * @ |) ([^ \ /? #:] *) (? :: (\ d +) |) |) /, Hc = {}, Ic = {}, Jc = "* /". concat ("*"); tente {zc = localização.href} catch (Kc) {zc = y.createElement ("a"), zc.href = "", zc = zc.href} yc = Gc.exec (zc.toLowerCase ()) || []; função Lc (a) {função de retorno (b, c) { "string"! = typeof b && (c = b, b = "*"); var d, e = 0, f = b.toLowerCase () .conjunto (E) || []; if (m.isFunction (c) )) while (d = f [e ++]) "+" === d.charAt (0)? (d = d.slice (1) || "*", (a [d] = a [d] | |] [unshift (c)): (a [d] = a [d] || []). push (c)}} função Mc (a, b, c, d) {var e = {} , f = a === Ic; função g (h) {var i; return e [h] =! 0, m.each (a [h] || [], função (a, h) {var j = h (b, c, d); return "string"! = typeof j || f || e [j]? f?! (i = j): void 0: (b.dataTypes.unshift (j), g (j) ,! 1)}), i} return g (b.dataTypes [0]) ||!e ["*"] && g ("*")} função Nc (a, b) {var c, d, e = m.ajaxSettings.flatOptions || {}; para (d em b) void 0! == b [d] && ((e [d]? a: c || (c = {})) [d] = b [d]); retorno c && m.extend (! 0, a, c), a} função Oc (a, b, c) {var d, e, f, g, h = a.contents, i = a.dataTypes; while ("*" === i [0]) i.shift (), void 0 === e && (e = a.mimeType || b.getResponseHeader ("Tipo de Conteúdo")); if (e) para (g em h) if (h [g] && h [g] .test (e)) {i.unshift (g); break} if (i [0] em c) f = i [0]; outro {para (g em c) {if (! i [0] || a.converters [g + " "+ i [0]]) {f = g; quebra} d || (d = g)} f = f || d} retorna f? (f! == i [0] && i.unshift (f), c [f]): void 0} function Pc (a, b, c, d) {var e f, g, h, i, j = {}, k = a.dataTypes.slice (); se (k [1]) para (g em a.converters) j [g.toLowerCase ()] = a.converterios [g]; f = k.shift (); enquanto (f) if (a.responseFields [f] && ( c [a.responseFields [f]] = b),! i && d && a.dataFilter &&(b = a.dataFilter (b, a.dataType)), i = f, f = k.shift ()) if ("*" === f) f = i; else if ("*"! == i && i! == f) {if (g = j [i + "" + f] || j ["*" + f],! g) para (e em j) if (h = e.split ("") , h [1] === f && (g = j [i + "" + h [0]] || j ["*" + h [0]])) {g ===! 0? g = j [ e]: j [e]! ==! 0 && (f = h [0], k.unshift (h [1])); break} se (g! ==! 0) if (g && a ["lança"] ) b = g (b); senão tente {b = g (b)} catch (l) {return {state: "parsererror", erro: g? l: "Nenhuma conversão de" + i + "para" + f " }} return {estado: "sucesso", dados: b}} m.extend ({ativo: 0, lastModified: {}, etag: {}, ajaxSettings: {url: zc, tipo: "GET", isLocal: Dc .test (yc [1]), global:! 0, processData:! 0, assíncrono:! 0, contentType: "aplicativo / x-www-form-urlencoded; conjunto de caracteres = UTF-8", aceita: {"*" : Jc, texto: "text / plain", html: "text / html", xml:"application / xml, text / xml", json: "aplicativo / json, texto / javascript"}, conteúdo: {xml: / xml /, html: / html /, json: / json /}, responseFields: {xml: "responseXML", texto: "responseText", json: "responseJSON"}, conversores: {"* texto": String, "texto html":! 0, "texto json": m.parseJSON, "texto xml": m .parseXML}, flatOptions: {url:! 0, contexto:! 0}}, ajaxSetup: function (a, b) {retorno b? Nc (Nc (a, m.ajaxSettings), b): Nc (m.ajaxSettings , a)}, ajaxPrefilter: Lc (Hc), ajaxTransporte: Lc (Ic), ajax: function (a, b) {"objeto" == tipo de a && (b = a, a = void 0), b = b | | {}; var c, d, e, f, g, h, i, j, k = m.ajaxConfiguração ({}, b), l = k.contexto || k, n = k.context && (l. nodeType || l.jquery)? m (l): m.event, o = m.Deferred (), p = m.Callbacks ("uma vez memória"), q = k.statusCode || {}, r = { }, s = {}, t = 0, u = "cancelado", v = {readyState: 0,getResponseHeader: function (a) {var b; if (2 === t) {if (! j) {j = {}; while (b = Cc.exec (f)) j [b [1] .toLowerCase ( )] = b [2]} b = j [a.toLowerCase ()]} retornar null == b? null: b}, getAllResponseHeaders: function () {retorno 2 === t? f: nulo}, setRequestHeader: function (a, b) {var = a.toLowerCase (); return t || (a = s [c] = s [c] || a, r [a] = b), esta}, overrideMimeType: function (a) {return t || (k.mimeType = a), isto}, statusCode: function (a) {var b; if (a) se (2> t) para (b em a) q [b] = [q [b], a [b]]; senão v.always (a [v.status]); retorne isto}, abort: function (a) {var b = a || u; return i && i.abort (b ), x (0, b), isto}}; if (o.promise (v) .complete = p.add, v.success = v.done, v.error = v.fail, k.url = (( a || k.url || zc) + ""). substitua (Ac, ""). substitua (Fc, yc [1] + "//"), k.type = b.method || b.type || k.method || k.type, k.dataTypes = m.trim (k.dataType || "*"). toLowerCase (). correspondência (E) || [""], null == k.crossDomain && (c = Gc.exec (k.url.toLowerCase ()), k.crossDomain =! (! c || c [1] === yc [1] && c [2] === yc [2] && (c [3] | | ("http:" === c [1]? "80": "443")) === (yc [3] || ("http:" === yc [1]? "80": "443")))), k.data && k.processData && "string"! = Tipo de k.data && (k.data = m.param (k.data, k.tradicional)), Mc (Hc, k, b, v ), 2 === t) return v; h = k.global, h && 0 === m.active ++ && m.event.trigger ("ajaxStart"), k.type = k.type.toUpperCase (), k .hasContent =! Ec.test (k.type), e = k.url, k.hasContent || (k.data && (e = k.url + = (wc.test (e)? "&": "?" ) + k.data, excluir k.data), k.cache ===! 1 && (k.url = Bc.test (e)? e.replace (Bc, "$ 1 _ =" + vc ++): e + (wc .teste (e)? "&": "?") + "_ =" + vc ++)), k.ifModificado && (m.lastModified [e] && v.setRequestHeader ("If-Modified-Since ", m.lastModified [e]), m.etag [e] && v.setRequestHeader (" Se-Nenhum-Correspondência ", m.etag [e])), (k.data && k.hasContent && k.contentType ! ==! 1 || b.contentType) && v.setRequestHeader ("Tipo de Conteúdo", k.contentType), v.setRequestHeader ("Aceitar", k.dataTypes [0] && k.accepts [k.dataTypes [0] ]? k.accepts [k.dataTypes [0]] + ("*"! == k.dataTypes [0]? "," + Jc + "; q = 0,01": ""): k.accepts ["* "]) para (d em k.headers) v.setRequestHeader (d, k.headers [d]); se (k.beforeSend && (k.beforeSend.call (l, v, k) ===! 1 | | 2 === t)) return v.abort (); u = "abortar"; para (d em {sucesso: 1, erro: 1, completo: 1}) v [d] (k [d]); if (i = mc (ic, k, b, v)) {v.readyState = 1, h && n.trigger ("ajaxSend", [v, k]), k.async && k.timeout> 0 && (g = setTimeout (função () {v.abort ("timeout ")}, k.timeout)); try {t = 1, i.send (r, x)} captura (w) {se (! (2> t)) lance w; x (-1, w) }} else x (-1, "Sem transporte"); função x (a, b, c, d) {var j, r, s, u, w, x = b; 2! == t && (t = 2 , g && clearTimeout (g), i = void 0, f = d || "", v.readyState = a> 0? 4: 0, j = a> = 200 && 300> a || 304 === a, c && (u = Oc (k, v, c)), u = Pc (k, u, v, j), j? (K.ifModified && (w = v.getResponseHeader ("Última modificação"), w && (m.lastModified [ e] = w), w = v.getResponseHeader ("etag"), w && (m.etag [e] = w)), 204 === a || "CABEÇA" === k.type? x = " nocontent ": 304 === a? x =" não modificado ":( x = u.state, r = u.data, s = u.error, j =! s)) :( s = x, (a || ! x) && (x = "erro", 0> a && (a = 0))), v.status = a, v.statusText = (b || x) + "", j o ​​o.resolveWith (l, [r, x, v]): o.rejectWith (l, [v, x, s]), v.statusCode (q), q = void 0, h && n.trigger (j? "ajaxSuccess ":" ajaxError ", [v, k, j? r: s]), p.fireWith (l, [v, x]), h && (n.trigger (" ajaxComplete ", [v, k]), --m.active || m.event.trigger ("ajaxStop")))} return v}, getJSON: function (a, b, c) {retorno m.get (a, b, c, "json") }, getScript: function (a, b) {retorno m.get (a, void 0, b, "script")}}), m.each (["get", "post"], função (a, b ) {m [b] = função (a, c, d, e) {retornar m.isFunção (c) && (e = e || d, d = c, c = void 0), m.ajax ({url : a, tipo: b, dataType: e, dados: c, sucesso: d})}}, m.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", " ajaxSend "], function (a, b) {m.fn [b] = function (a) {retornar this.on (b, a)}}), m._evalUrl = função (a) {return m.ajax ( {url: a, tipo: "GET", dataType: "script", assíncrono:! 1, global:! 1, "throws":! 0})}, m.fn.extend ({wrapAll: function (a) {if (m.isFunction (a)) retorna this.each (function (b) {m (this) .wrapAll (a.call (isso, b))}); if ( this [0]) {var b = m (a, este [0] proprietárioDocument) .eq (0) .clone (! 0); este [0] .parentNode && b.insertBefore (this [0]), b.map (function () {var a = this; while (a.firstChild && 1 === a.firstChild.nodeType) a = a.firstChild; retorna a}). append (this)} retorna isto}, wrapInner: function (a) {return this.each (m.isFunction (a)? function (b) {m (this) .wrapInner (a.call (isto, b))}: function () {var b = m (isto), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, wrap: function (a) {var b = m.isFunction (a); retorne this.each (função (c) {m (isto) .wrapAll (b? a.call (isto, c): a)})}, desembrulhar: function () {retornar this.parent (). each (function () {m.nodeName (this, "body") || m (this) .replaceWith (this.childNodes)}). end ()}}), m.expr.filters.hidden = função (a) {return a.offsetWidth <= 0 && a .offsetHeight <= 0 ||! k.reliableHiddenOffsets () && "nenhum" === (a.style && a.style.display || m.css (a, "display"))}, m.expr.filters.visible = function (a) {return! m.expr.filters.hidden (a)}; var Qc = /% 20 / g, Rc = / \ [\] $ /, Sc = / \ r? \ n / g, Tc = / ^ (?: submit | button | image | reset | arquivo) $ / i, Uc = / ^ (?: entrada | selecione | área de texto | keygen) / i; função Vc (a, b, c, d) { var e; if (m.isArray (b)) m.each (b, função (b, e) {c || Rc.test (a) - d (a, e): Vc (a + "[" + ( "objeto" == typeof e? b: "") + "]", e, c, d)}); senão se (c || "objeto"! == m.tipo (b)) d (a, b); senão para (e em b) Vc (a + "[" + e + "]", b [e], c, d)} m.param = função (a, b) {var c, d = [] , e = função (a, b) {b = m.isFunção (b)? b (): null == b? "": b, d [comprimento_longo] = encodeURIComponent (a) + "=" + encodeURIComponent (b)}; if (void 0 === b && (b = m.ajaxSettings && m.ajaxSettings.traditional), m.isArray (a) || a.jquery &&! m.isPlainObject (a)) m.each (a, function () {e (this.name, this.value)}); else para (c em a) Vc (c Retorna d.join ("&"). replace (Qc, "+") .serializeArray ())}, serializeArray: function () {retornar this.map (function () {var a = m.prop (isso, "elementos"); retorna a? m.makeArray (a): this}). filter (function () {var a = this.type; retorne this.name &&! m (this) .is (": disabled") && Uc.test (this.nodeName) &&! Tc.test (a) && (este. verificado ||! W.test (a))}). map (function (a, b) {var c = m (this) .val (); retorno null == c? null: m.isArray (c)? m.map (c, função (a) {return {nome: b.name, valor: a.replace (Sc, "\ r \ n")}}): {nome: b.name, valor: c.replace (Sc, "\ r \ n")}}). Get ()}}), m.ajaxSettings.xhr = void 0! == a.ActiveXObject? Function () {return! This.isLocal && / ^ (get | post | cabeça | colocar | excluir | opções) $ / i.test (this.type) && Zc () || $ c ()}: Zc; var Wc = 0, Xc = {}, Yc = m.ajaxSettings.xhr (); a.ActiveXObject && m (a) .on ("descarregar", function () {para (var a in Xc) Xc [a] (void 0,! 0)}), k.cors = !! Yc && "withCredentials" em Yc, Yc = k.ajax = !! Yc, Yc && m.ajaxTransport (função (a) {if (! A.crossDomain || k.cors) {var b; return {send: function (c, d) {var e, f = a.xhr (), g = + + + Wc; if (f.open (a.type, a.url, a.async, a.username, a.password), a.xhrFields) para (e em a.xhrFields) f [e] = a.xhrFields [e]; a.mimeType && f.overrideMimeType && f.overrideMimeType (a.mimeType), a.crossDomain || c ["Solicitado por X-com "] || (c [" X-pedido-com "] =" XMLHttpRequest "); para (e em c) void 0! == c [e] && f.setRequestHeader (e, c [e] +" ") f.send (a.hasContent && a.data || null), b = função (c, e) {var h,i, j; if (b && (e || 4 === f.readyState)) if (excluir Xc [g], b = void 0, f.onreadystatechange = m.noop, e) 4! == f.readyState && f .abort (); senão {j = {}, h = f.status, "string" == tipoof f.responseText && (j.text = f.responseText); tente {i = f.statusText} catch (k) { i = ""} h ||! a.isLocal || a.crossDomain? 1223 === h && (h = 204): h = j.ex. 200: 404} j && d (h, i, j, f.getAllResponseHeaders ())}, a.async? 4 === f.readyState? setTimeout (b): f.onreadystatechange = Xc [g] = b: b ()}, abortar: function () {b && b (void 0,! 0)}}}}); função Zc () {try {retornar novo a.XMLHttpRequest} catch (b) {}} função $ c () {try {retornar novo a.ActiveXObject ("Microsoft.XMLHTTP")} capturar (b) {}} m.ajaxSetup ({aceita: {script: "texto / javascript, aplicativo / javascript, aplicativo / ecmascript, aplicativo / x-ecmascript"}, conteúdo: {script: / (?: java | ecma) script /}, conversters: {"script de texto":função (a) {return m.globalEval (a), a}}}, m.ajaxPrefilter ("script", função (a) {void 0 === a.cache && (a.cache =! 1), um .crossDomain && (a.type = "GET", a.global =! 1)}), m.ajaxTransport ("script", função (a) {if (a.crossDomain) {var b, c = y.head | | m ("head") [0] || y.documentElement; return {enviar: function (d, e) {b = y.createElement ("script"), b.async =! 0, a.scriptCharset && (b .charset = a.scriptCharset), b.src = a.url, b.onload = b.onreadystatechange = função (a, c) {(c ||! b.readyState || / carregado | completo / .teste (b .readyState)) && (b.onload = b.onreadystatechange = null, b.parentNode && b.parentNode.removeChild (b), b = nulo, c || e (200, "sucesso"))}, c.insertBefore (b , c.firstChild)}, abort: function () {b && b.onload (void 0,! 0)}}}}); var _c = [], ad = / (=) \? (? = & | $) | \? \? /; m.ajaxSetup ({jsonp: "callback",jsonpCallback: function () {var a = _c.pop () || m.expando + "_" + vc ++; retorne esta função [a] =! 0, a}}), m.ajaxPrefilter ("json jsonp", b, c, d) {var e, f, g, h = b.jsonp! ==! 1 && (ad.test (b.url)? "url": "string" == tipo de b.data &&! (b .contentType || ""). indexOf ("application / x-www-form-urlencoded") && ad.test (b.data) && "data"); return h || "jsonp" === b.dataTypes [ 0]? (E = b.jsonpCallback = m.isFunction (b.jsonpCallback)? B.jsonpCallback (): b.jsonpCallback, h? B [h] = b [h] .replace (anúncio, "$ 1" + e ): b.jsonp! ==! 1 && (b.url + = (wc.test (b.url)? "&": "?") + b.jsonp + "=" + e), b.converter ["script json "] = function () {return g || m.error (e +" não foi chamado "), g [0]}, b.dataTypes [0] =" json ", f = a [e], a [ e] = function () {g = argumentos}, d.sempre (function () {a [e] = f, b [e] && (b.jsonpCallback = c.jsonpCallback, _c.push (e)), g && m.isFunction (f) && f (g [0]), g = f = void 0}), "script"): void 0}), m.parseHTML = função (a, b, c) {if (! a || "string"! = tipo de a) return null; "booleano "== typeof b && (c = b, b =! 1), b = b || y; var d = u.exec (a), e =! c && []; retorno d? [b.createElement (d [ 1])] :( d = m.buildFragment ([a], b, e), e && e.length && m (e) .remove (), m.merge ([], d.childNodes))}; var bd = m .fn.load; m.fn.load = function (a, b, c) {if ("string"! = tipo de um && bd) return bd.apply (isto, argumentos); var d, e, f, g = this , h = a.indexOf (""); return h> = 0 && (d = m.trim (a.slice (h, a.length)), a = a.slice (0, h)), m.isFunction (b)? (c = b, b = void 0): b && "objeto" == typeof b && (f = "POST"), g.length> 0 && m.ajax ({url: a, tipo: f, dataType:"html", dados: b}). done (função (a) {e = argumentos, g.html (d? m ("<div>"). append (m.parseHTML (a)). find (d) : a)}). complete (c && função (a, b) {g.each (c, e || [a.responseText, b, a])}), this}, m.expr.filters.animated = function ( a) {return m.grep (m.timers, função (b) {return a === b.elem}). length}; var cd = a.document.documentElement; function dd (a) {return m.isWindow (a)? a: 9 === a.nodeType? a.defaultView || a.parentWindow:! 1} m.offset = {setOffset: função (a, b, c) {var d, e, f, g , h, i, j, k = m.css (a, "posição"), l = m (a), n = {}; "estático" === k && (a.style.position = "relativo") , h = l.offset (), f = m.css (a, "topo"), i = m.css (a, "esquerda"), j = ("absoluto" === k || "fixo" === k) && m.inArray ("auto", [f, i])> -1, j? (d = l.position (), g = d.top, e = d.left): (g = parseFloat (f) || 0, e = parseFloat (i) || 0), m.isFunção (b) && (b = b.call (a, c, h)), nulo! = b.top && (n.top = b.top-h.top + g), nulo! = b.left && (n.left = b .left-h.left + e), "using" em b? b.using.call (a, n): l.css (n)}}, m.fn.extend ({deslocamento: funo (a) { if (arguments.length) return void 0 === a? this: this.each (function (b) {m.offset.setOffset (isto, a, b)}); var b, c, d = {topo: 0, left: 0}, e = this [0], f = e & e.ownerDocument; if (f) return b = f.documentElement, m.contains (b, e)? (Tipoof e.getBoundingClientRect! == K && ( d = e.getBoundingClientRect ()), c = dd (f), {topo: d.top + (c.pageYOffset || b.scrollTop) - (b.clientTop || 0), à esquerda: d.left + (c. pageXOffset || b.scrollLeft) - (b.clientLeft || 0)}): d}, posição: function () {if (isto [0]) {var a, b, c = {topo: 0, à esquerda: 0}, d = this [0]; retorno "fixo" === m.css (d, "posição")? B = d.getBoundingClientRect () :( a = this.offsetParent (), b = this.offset (), m.nodeName (a [0], "html") || (c = a.offset ()), c.top + = m.css (a [0], "borderTopWidth",! 0), c.left + = m.css (a [0], "borderLeftWidth",! 0)), {topo: b.top-c.top-m. css (d, "marginTop",! 0), à esquerda: b.left-c.left-m.css (d, "marginLeft",! 0)}}}, offsetParent: function () {return this.map ( function () {var a = this.offsetParent || cd; while (a &&! m.nodeName (a, "html") && "static" === m.css (a, "posição")) a = a. offsetParent; retorna a || cd})}}, m.each ({scrollLeft: "páginaXOffset", scrollTop: "pageYOffset"}, função (a, b) {var = = Y / .test (b); m.fn [a] = função (d) {retorno V (isto, função (a, d, e) {var = f f = dd (a); retorno void 0 === e? f? b in f? f [ b): f.document.documentElement [d]: um [d]: void (f? f.scrollTo (c? m (f) .scrollLeft (): e, c? e: m (f) .scrollTop () ): a [d] = e)}, a, d, arguments.length, null)}}), m.each (["top", "left"], função (a, b) {m.cssHooks [ b] = Lb (k.pixelPosition,função (a, c) {retorno c? (c = Jb (a, b), Hb.test (c)? m (a) .posição () [b] + "px": c): void 0}) }), m.each ({Height: "height", Width: "largura"}, function (a, b) {m.each ({preenchimento: "interior" + a, conteúdo: b, "": "externo "+ a}, função (c, d) {m.fn [d] = função (d, e) {var f = argumentos.length && (c ||" booleano "! = tipo d), g = c || (d ===! 0 || e ===! 0? "margin": "border"); return V (isto, função (b, c, d) {var e; return m.isWindow (b)? b.document.documentElement ["client" + a]: 9 === b.nodeType? (e = b.documentElement, Math.max (b.body ["rolagem" + a], e ["rolagem" + a ], b.body ["offset" + a], e ["offset" + a], e ["cliente" + a])) void 0 === d? m.css (b, c, g) : m.style (b, c, d, g)}, b, fd: void 0, f, null)}})}), m.fn.size = function () {retorne este.length}, m.fn.andSelf = m.fn.addBack, "function"== typeof define && define.amd && define ("jquery", [], function () {return m}); var ed = a.jQuery, fd = a. $; return m.noConflict = função (b) {return a. === m && (a. $ = fd), b && a.jQuery === m && (a.jQuery = ed), m}, tipo de b === K && (a.jQuery = a. $ = m), m} );
